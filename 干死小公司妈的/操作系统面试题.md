+ 进程与线程区别

  1. **进程是资源分配的最小单位，线程是CPU调度的最小单位**

  2. 线程依赖于进程而存在，一个进程至少有一个线程；

  3. 进程有自己的独立地址空间，线程共享所属进程的地址空间；

  4. 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，**只拥有一点在运行中必不可少的资源(如栈，寄存器，程序计数器)**，和其他线程**共享本进程的相关资源如堆内存**、I/O、cpu等；

  5. 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，**进程切换的开销远大于线程切换的开销；**

  6. 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；

  7. **多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，**因为进程有自己的独立地址空间，因此多进程更加健壮

     注意：这里每个线程拥有的资源都在一个TCB结构里面，线程切换的时候要保存这个TCB结构，TCB结构里面通过栈指针来保存栈信息，**实际上各个线程栈所在的位置还是进程的内存中**

+ 进程间通信（IPC）的方式，哪种最快

  1. 命名管道
  2. 消息队列
  3. 信号(Signal)
  4. 共享内存**（最快的IPC方式）**
  5. 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态
  6. 套接字(Socket)

+ 三种进入内核态方式：系统调用；异常；外围设备中断

  1. 系统调用：比如读取命令行输入。本质上还是通过中断实现

  2. 用户程序发生异常时：比如缺页异常

  3. 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序

+ 并发（concurrency）和并行（parallelism）

  并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在processor上运行（在go里面是一个工作线程M），宏观上的并发是通过不断的切换实现的；

  并行：并行是让不同的代码片段**同时**在不同的processor上（或者thread上，一个thread理论上对应一核）执行。

+ 内核态和用户态的区别：	

  1. 用户态和内核态的区别是，内核态运行操作系统程序，操作硬件，用户态运行用户程序；

  2. 用户态只能受限地访问内存，且不允许访问外围设备，没有调度CPU的能力

  3. 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。
  4. linux里面，当程序运行在3级特权级上时（Ring3），可以称之为运行在用户态，当程序运行在0级(Ring0)特权级上时，称之为运行在内核态。

+ 为什么要分内核态和用户态

  1. 在cpu中有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)、设置时钟等。如果所有的程序都能使用这些指令，那么你的系统一天死机n回就不足为奇了。
  2. 为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。
  3. 简易性（封装性），用户程序不需要实现更加底层的代码，比如select，epoll这种多路IO的方法，会封装一些接口给用户需要调用，而把与内核的一些交互交给这些方法去做。
  4. 利于调度，如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。而且如果都交给用户调度，肯定死锁，因为各家公司开发的代码不会去考虑别人家公司的情况。

+ 线程与协程切换的过程

  <https://blog.csdn.net/qq_40276626/article/details/122075129>
  
+ 什么时候用多线程什么时候用多进程呢？

  计算密集型：绝大多数时间在计算时最好用 - 多进程， 而在I/O密集型（IO 处理中大多时间是在等待，涉及到频繁的唤醒等待，即涉及到频繁的线程切换) 的时候最好用 - 多线程。
  
+ 死锁产生条件

  - **互斥**：一个资源一次只能被一个进程使用；
  - **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
  - **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
  - **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

+ 死锁解除的方法：

  - 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；
  - 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；
  - 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。

+ 死锁预防

  基本思想是破坏形成死锁的四个必要条件：

  - 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；
  - 破坏占有并等待条件：
    - 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；
    - 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；
    - 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；
  - 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；
  - 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。
  
+ 虚拟内存

  1. linux的swap分区就是虚拟内存的一部分，虚拟内存我的理解就是每个进程有一个虚拟地址空间，这个空间是分页的，然后每个进程有一个页表，页表存在内存里面，页表记录的是页号（虚拟地址）对应的页框号（物理地址），和一些标志位（主要和页面淘汰有关），页表起始地址存在PCB里面，进程按内存寻址的时候是输入的虚拟地址，然后通过页表上面映射到物理内存空间，如果物理内存中没有这一页，就从swap中调进来
  2. 进程在运行时，需要将页表放在内存中。但在虚拟地址空间很大的情况下，可能无法全部载入内存。
  3. 虚拟内存的优点是让程序可以获得更多的可用内存。