# RDB内存快照

## RDB 用处

对 Redis 来说，RDB快照就是把当前内存中的数据存到磁盘里面去。生成的文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。当发生宕机的时候，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。而不需要像用AOF日志恢复一样，一条一条的执行一遍AOF日志。

RDB快照是全量快照，也就是一次快照，就把所有的内存数据都存到磁盘里面

## RDB 如何操作

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

+ save：在主线程中执行，会导致阻塞；
+ bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

### 避免阻塞

使用bgsave生成RDB文件，**避免阻塞主线程**

注意：

1. 上面有一个问题，**就是避免阻塞和正常处理写操作并不是一回事**。用bgsave的时候主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，**它只能处理读操作，不能执行写操作**。因为不能修改正在执行快照的数据。
2. bgsave 子进程是由主线程 fork 生成的，**共享主线程的所有内存数据（不是复制一份）**。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。

### 支持写操作

为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/a2e5a3571e200cb771ed8a1cd14d5558.jpeg"  style="zoom:4%"  />

+ bgsave和主线程共用一块内存，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。
+ 如果主线程要修改一块数据（例如图中的键值对 C）那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。

## 快照频率与防止宕机丢失

如果我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了，这部分数据丢失。

解决上述宕机问题可以使用频繁快照的方式，但fork子线程这个操作会阻塞主线程，如果频繁fork就会阻塞主线程很严重了，而且内存越大，阻塞时间越长。这个时候可以用增量快照缓解一下内存过大的情况，但又会有问题：<https://time.geekbang.org/column/article/271839>

为了解决上述问题，Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/e4c5846616c19fe03dbf528437beb320.webp"  style="zoom:20%"  />

第一次全量快照后，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

这样有两个好处：

1. 防止宕机丢失，也不需要频繁快照了
1. 这样AOF日志就不会过大了，这样省去AOF重写了

