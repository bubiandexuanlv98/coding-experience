# Redis数据结构

## 键值数据结构

redis的键值对是用hash表存储的，很显然。

hash表是用数组存储的，且数组元素是一个桶，桶里面包含一个指向key的指针和指向value的指针，**注意是指针不是值，和golang的map不一样**

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.webp"  style="zoom:30%"  />

### hash 冲突解决

拉链法

### Rehash操作

链式哈希的一个问题就是，链表太长影响效率。这个时候redis会通过**增加哈希桶，然后rehash的方法把entry均匀分布在数组中（注意不是直rehash）**

#### Rehash如何解决阻塞问题

rehash的操作会带来阻塞，因为要整体迁移。

为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

第二步是最耗时的，**redis采用了渐进式rehash**的方法

#### 渐进式rehash过程

简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/73fb212d0b0928d96a0d7d6ayy76da0c.webp"  style="zoom:30%"  />

可以看出这个和golang的map有一个不同，就是golang的map迁移是一次迁两个，包括访问的那个。

## 集合类型的底层结构

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/8219f7yy651e566d47cc9f661b399f01.webp"  style="zoom:10%"  />

### 压缩列表

压缩列表结构：<https://zhuanlan.zhihu.com/p/71880195>

压缩列表(zip1ist)是列表和哈希的底层实现之一。

注意压缩列表和普通数组最大的区别是，数组的元素长度是固定的。但是压缩列表的元素长度是不定的，数组也可以存储长度不同的元素，比如长度不同的字符串，但是这样的话**数组的大小就必须以长度最长的字符串为准**，显然这是一种内存浪费

而数组包括压缩列表比起链表的优势是：

1. 内存利用率高，因为前两者都是紧凑排列，内存碎片少，比链表占用的内存要更少
2. 数组对CPU高速缓存支持更友好（因为CPU可以一下读入一大段甚至整个数组进入cache），所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。

#### 压缩列表结构：

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/20210507102218979.png"  style="zoom:100%"  />

zlbytes：存储一个无符号整数，固定四个字节长度，表示存储压缩列表所占用的字节

zltail：存储一个无符号整数，固定四个字节长度，代表指向列表尾部的偏移量

zllen：压缩列表包含的节点个数，固定两个字节长度，源码中指出当节点个数大于2^16-2个数的时候，该值将无效，此时需要遍历列表来计算列表节点的个数。

entryX：列表节点区域，**长度不定**，由列表节点紧挨着组成。

zlend：一字节长度固定值为255，用于表示列表结束。

#### 压缩列表节点结构

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/压缩列表节点.png"  style="zoom:50%"  />

previous_entry_length：记录了压缩列表中前一个节点的长度。 

encoding：保存了content的内容类型以及长度

content：保存节点的内容

#### 如何操作

<https://segmentfault.com/a/1190000040669482/en>

注意，在源码中，可以看出遍历的时候，是可以计算出当前节点的长度的。所以不需要一个current_entry_length，但是当倒序遍历的时候，是没办法判断上一节点的头结点在哪的，所以需要previous_entry_length。

#### 何时使用压缩列表

1. 当一个列表只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表的底层实现。
2.  当一个哈希只包含少量键值对,比且每个键值对的键和值要么就是小整数值,要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做哈希的底层实现。

从上面可以看出压缩列表的entry里面可以存的就是小整数值和较短的字符串

### 跳表

跳表（skiplist）是有序列表（zset）的实现方式

#### 跳表的结构

跳表的结构就是为了降低时间复杂度而生的，每一级都按照每n个节点提取一个节点到上面一级，下面这个例子是每一级都是每两个节点提取一个节点到上面一级

<img src="/Users/yixia/Desktop/coding-experience/干死小公司妈的/图片/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTk4OTQ3OS01ZDM2NjQ2ODdmY2MxZTQ3LmpwZw.png"  style="zoom:50%"  />

根据上图得知，**每级遍历 3 个结点即可（这是最多，有时候两个就可以）**，而跳表的高度为 h ，所以每次查找一个结点时，需要遍历的结点数为 `3*跳表高度` ，所以忽略低阶项和系数后的时间复杂度就是 （Olog(n)）。所以上面这个跳表相当于二分查找。

#### 跳表的操作

<https://blog.csdn.net/qq_38545713/article/details/105439688>

注意：

插入操作要随机一下，得到k以后，从1到k层都要接上这个节点

删除操作要注意，如果删除的节点是在索引层上面的，要注意除了底层的节点，索引层的节点也有删掉

#### 跳表的优势

首先跳表不能跟hash比，因为它是为了实现有序列表的。因此只能拿它跟有序的结构比，比如红黑树，B树。但B树和红黑树如果是内存数据库是差不多的，而且红黑树可能在内存中性能更好，因为它快。所以统一用红黑树比较吧

1. 其中，插入、查找、删除以及迭代输出有序序列这几个操作，红黑树也能完成，时间复杂度和跳表是一样的，但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。 对于按照区间查找数据这个操作，跳表可以做到 ○(㏒n) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。 

2. 当然，还有其他原因，比如，跳表代码更容易实现，可读性好不易出错。跳表更加灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。 