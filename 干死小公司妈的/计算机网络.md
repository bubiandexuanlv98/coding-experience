1. TCP建立连接可以两次握手吗？为什么?

   不行，两次就是指第三次不要了，第三次不要了以后，如果客户端没有收到服务端的回应（即第二次握手没收到）这个时候，客户端认为没有建立，服务端却为认为建立成功，并保存了必要的资源，如果出现大量的这样的情况。那么服务器会奔溃。
   **因此第三次握手是必要的。**

2. 可以采用四次握手吗？为什么？

   可以，没必要，会降低传输的效率。

3. 为什么第二次握手syn要置1？

   因为我的理解是这是表明这个第二次握手是第一次握手的响应，因为SYN这个标志位只有在TCP握手的时候才会被置为1。

4. 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

   + 服务端

     由于Server没有收到ACK确认，因此会重发之前的SYN+ACK**（默认重发五次，之后自动关闭连接进入CLOSED状态）**，Client收到后会重新传ACK给Server。

   + 客户端

     1. 在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态**（即发送了正常的信息也算发送第三次握手包）**
     2. 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。

4. 如果已经建立了连接，但客户端出现了故障怎么办？

   服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

5. 初始序列号/ack number是什么

   TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据按字节编号：如果发送数据包序列号为1，数据长度为1000字节，则对方会发送一个ack number为1001回去。接下来发送方就会发送序列号为1001的数据包了。序列号用处如下：

   1. 既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将按照sequence number对失序数据进行重新排序，然后才交给应用层；
   2. 如果发送方没有收到与sequence number相对应的ack number，那么发送方就会超时重发

6. TCP如何保证数据可靠性

   1. 数据包校验

      目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；

   2. 对失序数据包重新排序（TCP报文具有序列号）

      既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；

   3. 丢弃重复数据

   4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；

   5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；

   6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

7. TCP和UDP的本质区别：

   1. TCP是面向连接的，UDP是无连接的；
   2. UDP结构简单，TCP复杂，而且TCP对系统资源要求高一点
   3. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等），如果网络拥塞，UDP会直接丢包，不保证数据完整性和顺序性，而这个TCP通过应答+超时重发+序列号/ack number保证了完整性和数据顺序。（虽然UDP不保证顺序，但是应用层的协议也可以有顺序控制，这就是为啥打视频不会出现乱序的情况）

8. HTTPS怎么确认收到的包就是服务器发来的

   <https://zhuanlan.zhihu.com/p/22142170>

   为了解决**“在在三次握手或者客户端发起HTTP请求过程中，中间人劫持客户端请求，自己向服务端请求建立http，然后用自己的公钥当成服务端的公钥发给客户端”引起的中间人攻击**”，我们引入了数字证书的概念。服务器首先生成公私钥，将公钥提供给相关机构（CA），CA将公钥放入数字证书并将数字证书颁布给服务器，此时服务器就不是简单的把公钥给客户端，而是给客户端一个数字证书，数字证书中加入了一些数字签名的机制，保证了数字证书一定是服务器给客户端的。中间人发送的伪造证书，不能够获得CA的认证，此时，客户端和服务器就知道通信被劫持了。**这里注意：因为中间人不拥有能解开服务端公钥的私钥，所以如果中间人把证书透传，后序继续劫持客户端请求，它仍然无法获取由服务端公钥加密的对称秘钥，保证了通信的加密性**

9. GET与POST的区别？

   1. GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；
   2. GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；
   3. 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；
   4. 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；
   5. GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；
   6. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制
   
9. 如何防范session劫持

   https://blog.csdn.net/weixin_48052161/article/details/110520511
   
9. 跨域问题

   <http://www.ruanyifeng.com/blog/2016/04/cors.html>
   
   一个用户用浏览器访问我们公司的A url的网页上  请求了咱们公司B url的资源  浏览器会帮用户自动在请求头中加入一个origin字段（这里我们只讨论简单请求） 然后我们需要在B url对应的资源的后端js代码中加入对A url发过来的跨域请求的支持（通过在响应头中设置Access-Control-Allow-Origin等）然后浏览器会收到B url发回来的响应  发现头中带有Access-Control-Allow-Origin等字段  请求成功