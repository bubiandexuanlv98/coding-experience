# 事务

事务支持是在引擎层实现的，并不是所有引擎都支持事务，InnoDB支持，下面讲解都以InnoDB为准

## 事务四种隔离级别

+ **读未提交**是指，一个事务还没提交时，它做的变更就能被别的事务看到。
+ **读提交**是指，一个事务提交之后，它做的变更才会被其他事务看到。
+ **可重复读**是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
+ **串行化**，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

现在有一个数据库，数据表 T 中只有一列，其中一行的值为 1，这个表是：

```sql
create table T(c int) engine=InnoDB;
insert into T(c) values(1);
```

现在有两个事务A和B，当他们是上述四种隔离级别的时候，V1，V2，V3分别如下

<img src="https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png"  style="zoom:30%"  />~

+ 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
+ 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
+ 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
+ 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

### 视图的概念

可重复度和读提交两个级别下，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准6

在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。

“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问，也没有视图概念。



## 事务隔离的实现

事务隔离的实现就是靠回滚日志（undo log实现的），记住，后面再说

这里以“可重复读”为例来介绍一下，有一个数据c从1被依次增加，到最后变成4，下图A，B，C是三个可重复读隔离级别的事务，各自会产生一个视图，注意这个事务不是指修改c，而是指修改c为那个值后起一个RR的事务去读。

<img src="https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png"  style="zoom:30%"  />

回滚日志会一直保留，**直到系统里没有比这个回滚日志更早的 read-view 的时候**。怎么理解上一段中加粗的话：比如对于A事务，假如它是针对c进行的操作，操作失败要回滚，可是现在都已经变成4了，所以4前面那三个回滚日志都要保留，以用于回滚。**因此尽量不要使用长事务**

### 事务的启动方式

1. 如果set autocommit=1，使用begin 或 start transaction启动事务。配套的提交语句是 commit，回滚语句是 rollback。
2. 如果set autocommit=0，接下来你只要执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。

注意无论autocommit是啥都要显式执行commit才能提交，区别只是要不要begin这个关键字上面。在这个值为1的时候begin是可以省掉的：使用commit work and chain语法即可

