# 索引

## 索引模型

### 哈希表

MySQL如果使用hash索引，索引冲突解决是采用拉链法

+ 优点 

哈希索引查询速度快，而且加入速度也快，都是O(1)就解决了，适用于等值查询

+ 缺点

哈希表适用于只有等值查询的场景，**不适用于范围查询（或者说范围查询很慢），**这个很好理解，你那个拉链法，是按照插入的时间顺序一个一个的插入进去的，并不是值有序的

### 有序数组

这个优缺点很显然了，等值速度和范围查询都很优秀，但是添加一个元素太慢了，因为需要把这个元素后面的元素都往后挪

### 二叉树

这里主要讲B树为何优于二叉树搜索树：

1. 二叉树的查询效率比B树高，但是二叉树存在磁盘里面太费资源了。一棵 100 万节点的平衡二叉树，树高 20。查找一个值可能需要访问 20 个数据块，这是因为，以InnoDB举例，它按照页读取，可能一页里面有多个二叉节点（也可以认为设成一个，比如设置页大小为一个二叉节点大小），但可能有效的就一个，然后你要根据这个节点中的信息去找下一个。这种操作需要20次

2. 但是如果是N叉树，N是1200，10亿节点，树高是4，查找一个值查找一个值最多只需要访问 3 次磁盘（因为根节点始终在内存中）。树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

   MySQL中的N叉树，**也就是B+树牛逼在它把每一个节点（非叶子和叶子节点都是这样）设成一个磁盘页的大小**，InnoDB读取的时候是按照磁盘页读取的，这样充分利用了磁盘预读的功能，而且读的时候是按磁盘页读取的，读一个磁盘页就读取一个节点，很方便，降低了IO的开销

**因此比起二叉树，N叉树能够很好地配合磁盘的读写特性（其实就是读一次磁盘获取的信息比较多）**）

补充一下，红黑树和B树：

这里稍稍补充一个知识点：红黑树和B树的区别，红黑树实际上是平衡二叉搜索树的一种实现方式，平衡二叉搜索树非常麻烦，因为你添加和删除都要把树重新变得平衡起来。红黑树通过弱平衡来提高效率，但是仍然需要旋转（虽然这里的旋转已经是常数级了），B树就不需要。而且红黑树也是二叉树毕竟不适合不适合存在磁盘上，尤其是大数据量的时候，树高太高了。

### B树

#### B树

B树是在搜索二叉树基础上发展出来的多叉树，一棵m阶B-tree满足

+ 一个节点最多有m个子节点

+ 一个节点中包含k个元素（这里 m/2≤k<m，这里 m/2 向下取整），k个元素按关键词大小从小到大排列

+ 一个节点中的k个元素满足：位于每个元素左边的子节点的值（关键词的值）都小于等于该元素。位于每个元素右边的子节点的值（关键词的值）都大于等于该元素

  <img src="https://pic.leetcode-cn.com/1629446588-fpMLVA-B%E6%A0%91.png"  style="zoom:30%"  />

  ​													注意：关键词就是指索引字段，比如主键索引，关键字就是主键。B+ 树  

#### B+树

InnoDB使用的是B+树，虽然打印出来是“BTREE”，但实际上是B+树

- 所有的非叶子结点只存储 **关键字信息**；

- 所有具体数据都存在叶子结点中；

- 所有的叶子结点中包含了全部元素的信息；

- 所有叶子节点之间都有一个链指针。

  <img src="https://pic.leetcode-cn.com/1629448733-VWjqZc-B_%20Tree.png"  style="zoom:30%"  />

  InnoDB中B+树存储计算：<https://zhuanlan.zhihu.com/p/445919861>
  
  

### 索引模型比较

+ B+树比B树优秀在哪？

  1. IO次数少：由于 B+ 树的内部结点只存放键，不存放值，因此，一次读取，可以在同一数据页（MySQL是页，16kB）中获取更多的键，有利于更快地缩小查找范围。这也是B+树会比B树更矮胖，层数更少的原因
2. B+ 树的叶结点由一条链相连，因此当需要进行一次 全数据遍历 的时候，B+ 树只需要使用 O(logN) 时间找到最小结点，然后通过链进行 O(N) 的顺序遍历即可；或者，在找 大于某个关键字或者小于某个关键字的数据 的时候，B+ 树只需要找到该关键字然后沿着链表遍历即可。**但B树得中序遍历整个树**
  3. 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多

+ B树和Hash索引区别
  1. Hash 索引进行等值查询更快（一般情况下），但是却无法进行范围查询；
  2. Hash 索引不支持使用索引进行排序；
  3. Hash 索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生 Hash 碰撞，此时效率可能极差；而 **B+ 树的查询效率比较稳定**，对于所有的查询都是从根结点到叶子结点，且**树的高度较低**。
  4. Hash 索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为 Hash 函数的不可预测；
  5. Hash 索引任何时候都避免不了回表查询数据，而 B+ 树在符合某些条件（聚簇索引，覆盖索引等）的时候可以只通过索引完成查询；

## 索引维护

<img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png"  style="zoom:30%"  />

1. B+树每次添加新值的时候很显然需要做必要的维护，但是当数据非有序加入时，比如加入300，500，600。这个时候再加入400，可能就需要挪动这个叶子节点中300后面的数据（即500，600）
2. MySQL的最小存储单元是数据页，如果上图R3, R4, R5所在数据页已经满了，这个时候再加入400，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%



### 自增主键的意义

1. 有一个自增主键，这样保证每次插入都是递增插入，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。

   *页分裂的目的就是保证：（我认为叶子和非叶子都存在页分裂）后一个数据页中的所有行主键值比前一个数据页中主键值大。*

   页分裂：<https://www.cnblogs.com/ZhuChangwu/p/14041410.html>

   + 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

2. 自增主键有时候比别的属性做主键，占用空间少

   

## 索引类型

MySQL里面的索引分为主键索引和非主键索引，非主键索引的B+树的“数据”部分存放的是主键的值，因此使用非主键索引查询，**大部分时候需要回表**，即回到主键索引树上再找一遍，除了索引覆盖的情况

### 二级索引

上面说过，一般非主键索引（二级索引）都是要回表找主键索引的。比如对于`select * from T where k between 3 and 5` k上面有索引，且表里有k=3, 4, 5, 6四个数，k索引树上读一个数，回表一次。一直到k读到6，发现不满足，不回表

这个回表的过程很慢，有没有什么优化办法？

#### 联合索引

讲优化之前先强调一下什么事联合索引，比如有一个市民信息表：

```mysql
CREATE TABLE `tuser` (
  `id` int(11) NOT NULL,
  `id_card` varchar(32) DEFAULT NULL,
  `name` varchar(32) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `ismale` tinyint(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `id_card` (`id_card`),
  KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
```

id可以看成自增主键，id_card 是身份证号

如果建立（name，age）的联合索引，这个联合索引长这样：

<img src="https://static001.geekbang.org/resource/image/89/70/89f74c631110cfbc83298ef27dcd6370.jpg"  style="zoom:30%"  />

1. 可以看到这个索引虽然不是主键索引，但是它一个节点中包含的信息并不只有主键id，还有name和age，这就是联合索引牛逼的地方。
2. 还有一个点是，那个联合索引其实是经过**多字段排序**的，相当于`order by name, age`



### 普通索引和唯一索引

这两个索引的性能比较，查询操作两者相差不多，但是更新效率普通索引更高

#### 查询过程

唯一索引因为是唯一的，所以查询一次就行了。普通索引在查询到值以后还要继续向下读，因为有可能会有重复的。一直读到没重复的。这两个操作的性能差异微乎其微

注意：InnoDB的数据读取是按照数据页读取的。16kB的数据页，如果是整数字段上面的索引，那么可以存放数千个key

#### 更新过程

二者的更新过程的区别主要在**唯一索引不能使用change buffer，但普通索引可以**（注：change buffer在日志系统里面讲到，是一种节省随机读磁盘IO损耗的方法）

+ 普通索引是咋使用change buffer的？

​	当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下。InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。**在下次查询需要访问这个数据页的时	候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作**，本质上是一种延迟更新

+ 唯一索引为啥不能使用change buffer？

1. 如果需要的数据页已经在内存里面了，那直接更新更快（对普通索引也是这样的）
2. 如果需要的数据页不在内存，那必须要读到内存里面，因为InnoDB要判断更新过后这个key是否真的唯一

因此综上所述，尽量使用普通索引

### 索引优化

#### 创建索引的规则

1. 在 查询中很少使用 或者参考的列不要创建索引。由于这些列很少使用到，增加索引反而会降低系统的维护速度和增大空间需求。
2. 只有很少数据值的列 也不应该增加索引。由于这些列的取值很少，区分度太低，例如人事表中的性别，在查询时，需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
3. 定义为 text、image 和 bit 数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
4. 当 修改性能远远大于检索性能 时，即修改次数大于检索次数。不应该创建索引。这时因为，二者是相互矛盾的，当增加索引时，会提高检索性能，但是会降低修改性能。
5. 定义有 外键 的数据列一定要创建索引。

#### 覆盖索引

在上图中看到的一个节点中包含的信息并不只有主键id，还有name和age，这就构成了可以覆盖索引的条件，比如**你想按照name查找age**，就可以直接在这个name_age索引上进行，**而不需要回表**，因为索引出来的节点就已经包含了所需信息

#### 最左前缀原则

这个指的就是：查询where子句中的条件不需要和索引完全相等，只要这些条件满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。

1. 比如(a,b,c)上面有索引，那么查询where子句中的条件如果有a，ab，abc，都可以使用这个索引（**注意顺序，这些条件在where语句中的顺序无所谓**）。但是注意，如果条件仅是b，或者bc是不能使用这个索引的。能不能根据最左前缀原则使用索引where语句中条件的”顺序“无关，和条件的“类型”有关。
2. 如果a中是一个字符串，那么如果where子句中有类似于`where a like '张%'`这种也是可以根据最左前缀原则使用索引
3. **一定要注意最左前缀匹配原则会一直向右匹配直到遇到 范围查询（>、<、between、like）就停止匹配**，比如采用查询条件 `where a = 1 and b = 2 and c > 3 and d = 4 `或者时`where a = 1 and b = 2 and c > 3 and d like '张%' `，如果建立（a,b,c,d）顺序的索引，d 是用不到索引的。
3. 注意第三点是值得商榷的，因为只是知道会用到这个索引，但不知道是不是都用到了，不知道现在的优化怎么样。**但可以确定的是如果a就是范围查询，也许会用到索引**，这是现在的优化，非常nice，但是这个用到是基于innodb的采样的，如果觉得索引可以增加效率就是用索引。
3. 注意（>、<、between、like、in）这些查询其实也是有可能用到索引也可能不用到的，范围查询里面的东西经过innodb采样如果大于50%就不走索引：https://www.codeleading.com/article/40983084147 从5.7以后都是这样
3. 最最关键的来了！！！！！！！！全宇宙最关键的点，八股文王八蛋的地方来了！！！：**abc联合索引，ac可以走索引（ac还可以索引下推）**，不光ac，所有带a的全都可以走索引，bc不可以，c也不可以。其他关键的比较：<https://www.jianshu.com/p/499cf5795de5>

#### 索引下推

还是以上面那个(name, age)为例，

如果有一条语句长这样`select * from tuser where name like '张%' and age=10 and ismale=1`，如果没有索引下推优化的话，根据最左前缀原则的应用这个(name, age)索引找到到` name like '张%'`就结束了，然后把所有的’张%‘对应的主键id找出来一个个回表。如图

<img src="https://static001.geekbang.org/resource/image/b3/ac/b32aa8b1f75611e0759e52f5915539ac.jpg"  style="zoom:30%"  />

如果有索引下推优化的话，索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。在上面那个例子中，也就是说那个(name, age)索引会找到`name like '张%'`，然后会针对(name, age)这个索引中，对所有`name like '张%'`的节点中的age做判断，过滤掉age不等于10的节点，然后把剩下节点的主键id找出来一个一个回表，这样做少回表两次：

<img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg"  style="zoom:30%"  />

