# 贪心算法


## 选择问题
首先有两种操作，分数不一样，最终要求最大的分数，很可能就是贪心解法。
### 删除子字符串的最大得分
这道题处理过程特别像有效的括号里面除了括号还加了一大堆字母，但在这之前还有一个外壳，就是贪心
1. 这道题使用贪心的是因为a和b数量一定，比如去掉ab得分大，那么不可能出现去掉ab以后，还剩两个ba的情况，也就是说不去掉ab也最多只能去掉一个ba，相比之下，应该去掉ab
2. 这道题用栈，是因为会出现aaabbb的情况，即嵌套的ab，这个和有效的括号一样。
3. 出栈的时候一定要判断一下栈里还有没有元素，不然索引越界了，跟有效的括号那道题一模一样。 

### 交换字符使得字符串相同
这道题其实是一道隐含的选择问题，这道题的前两个示例给了思路，应该尽量选择xx/yy的那种交换，因为那种交换“得分”少
1. 首先两个中必须要有偶数个x/y + y/x，即不相等的情况有偶数个
2. 偶数个不相等的情况要尽量凑成xx/yy那种，少凑成xy/yx那种，这就要求统计x/y和y/x有多少个，尽量凑成xx/yy，x/y的个数奇数和偶数的最终计算结果不一样

### [分发糖果](https://leetcode-cn.com/problems/candy/)

1. 这道题难在它不是单向的，对于每一个位置i，他既要满足如果ratings大于i-1位置的话，个数要大于i-1，同理ratings要大于i+1位置的话，个数要大于i+1位置的。但是一轮循环，只能填满一个方向的个数数组，因此需要两轮循环分别从左到右，从右到左，填满两个数组left和right
2. 最后每个位置上的个数取left和right在对应位置上的最大值

### [森林中的兔子](https://leetcode-cn.com/problems/rabbits-in-forest/)

1. 这道题有一个关键点就是：同种颜色的兔子说出的值一定是一样的！！，同时如果一个兔子说出cnt，那么这种颜色的兔子**一定**有cnt+1个
2. 这道题的贪心就是计算说出相同数量的兔子的个数有多少个，假设说出cnt数量的兔子有k个，如果k < cnt+1，**那么说明至少有cnt+1个**，如果k > cnt +1，贪心来了！！这里要假设**提问组中的兔子里面包含尽可能多的相同颜色的兔子**，才能让总数最小，那么同一种颜色最多能出现多少个在**提问组**里呢？答案是有多少出现多少，每种颜色最多出现`cnt+1`个。因此提问组里面可以有`k / (cnt+1)`个颜色的兔子被**全组提问**
3. k / (cnt+1)是被全组提问的兔子，如果不能整除，说明还有一种颜色的兔子和其它有着相同cnt+1个成员的颜色兔子没有被全组提问，因此最终如果有k个兔子说出了cnt，且k > cnt，那么最少有`math.Ceil(float64(v) / float64(k+1)) * float64(k+1)`个兔子，因为题目要最少，所以就用这个最少值计数，**然后对每一个k，cnt对都做这样的操作**

### 判断子序列

## 区间问题（区间彼此交叉或者不交叉）
区间问题一般都要先排序！

### 无重叠区间

### 用最少的箭头射爆气球
这两道题基本一样
要先排序，按第二个数升序！


### 视频拼接
1. 这道题有一个特别值得学习的点，就是如果我们在循环中存在需要改变迭代指针的值，那么可以不用传统的for循环三段式迭代。把指针写在循环外，for循环条件只判断指针边界，在循环内部更新指针。**但注意这种情况下内部更新指针的时候也要判断边界！！！！**
1. 这道题的**贪心体现在当有起点小于curEnd的片段的时候，选取那个end最远的片段作为下一个片段，而那个片段的end就是nextEnd**
1. 这道题要剔除掉start小于curEnd的项，循环内部再套一个循环用来剔除掉start小于curEnd的项同时更新nextEnd，然后出了内循环以后更新curEnd并计数count。循环终止条件除了下标越界，**还有当前位置的start 小于等于curEnd**
1. 循环中如果出现nextEnd >= time了，可以及时返回结果，不用继续迭代了
2. 注意那个count，这种题目**最不能的写法就是在循环里面写一个判断，判断中如果当前循环不变量被打破再计数count**这种会出问题的因为可能最后一个区间到整个数组遍历完都还没打破循环不变量。所以这种题目**一定要在一次循环里面通过内循环直接把循环不变量打烂，然后在满足循环不变量的时候更新count**

### 跳跃游戏1

迭代所有位置，每个位置都计算一下这个位置能到达的最远位置，更新全局最远位置，如果全局最远位置都无法到达某一位置i，那么跳跃就中断了（一定发生在0的后面，但不是所有0后面都中断），返回失败

### 跳跃游戏2
#### 动态规划解法
自底向上的复杂度事实上低一点
+ 自底向上
  数组定义是：到达某个位置的最小步数，这个需要两层循环，一个在前面跑另一个在后面追的那种。base case注意，每到一个位置先得把dp数组这个位置上的数置为无穷大。
+ 自顶向下
  函数定义时：从某个位置到达最后一个位置的最小步数，典型的动归的递归，当前问题依赖后面的子问题解决，base case 是最后一个位置，它到达最后一个位置的步数是0。
#### 贪心解法
其实这道题有点像视频拼接，但又不全是，**这两道题最好对比一下**，还是两个变量标记结尾，一个是end，一个是farthest，类似于视频拼接里面curEnd和nextEnd。
end和farthest初始化为0
有两种计次方法，第二种好用一点
1. 一种是落地记次数，这种必须次数从-1开始，上来就记次数，farthest不能超过n-1，因为必须保证最后一次落地是在最后一个位置。这个方法还要求对数组长度为1的提前判断
2. 一种是起跳记次数，这种必须次数从0开始，结尾必须在n-2，因为必须保证最后一次起跳必须在最后一个位置之前，在最后一个位置起跳就废了，因为会多增加一次
这个其实就如何从头跳到尾思路和跳跃游戏1的思路是一样的，但是这道题要给出最小步数，因此你必须知道是在哪一步跳的，因此你必须跳完每一轮的最远位置（即farthest）才能计数加1（第二种计数其实并没有跳完，只是模拟它跳完了）



### [任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

这道题是一道解题步骤极不合理的题目

1. 这道题要用到“桶思想”，首先总时间一定跟任务量最多的那个任务有关，因为那个任务决定了一个“最短时间”，就是假如只有那个任务的处理总时长。于是可以想到**用数量最多那个任务（假设为A）来做桶**，有几个任务A，就有几个桶
2. 然后是往桶里填任务，这里不合理的就来了，假设A有k个，k个任务需要`(k-1) * (n+1)`+1，然后每个A任务有一个桶（相当于有k个桶），每个桶里面有n个位置，这个时候注意！！！**除了数量和A数量一样的任务（比如任务B），其他任务无论你填多少个，都是这样的公式：`max(len(tasks), (k-1) * (n+1)+1 )`（这时候是假设没有任务B的时候）**，这个点是第一个关键
3. **第二个关键是对于任务B，你必须要k个桶每个桶放一个，不然就会比当前时间长了**，这个很关键，因为当k个桶每个桶放一个B的时候第k个桶就不再是1了，而是2。然后剩下所有的任务再放，就是这个公式`max(len(tasks), (k-1) * (n+1)+2 )`这就告诉我们如果有t个和任务A个数一样的任务，那么这个公式应该变成`max(len(tasks), (k-1) * (n+1)+t+1 )`，不用考虑t > n，因为那样的话就是len(tasks)
