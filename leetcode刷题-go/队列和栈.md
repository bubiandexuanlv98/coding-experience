# 队列

## 构建循环队列
这里一定要注意，**循环队列不能用一个头指针和一个尾指针！！！！！！**，会出大麻烦的！！！！，因为两点原因：
1. 如果使用两个指针，不好判空和判满，因为这两个情况是一样的。
2. 即使把判空判满区分开（即加入的时候尾指针进1加入，取出的时候取出当前头指针位置的元素），会出现加第一个元素的时候，在1位置加入而不是0位置，浪费了一个空位。而且当队列长度为0的时候直接加不进去了。
3. 即使使用链表中的加哨兵的方法，也没用，加哨兵其实就是把头指针置为-1，但他妈逼的我第一次加元素的时候还得把这个头指针置0，不然后面没法判满，而且不统一，代码会像屎一样
除此之外注意Rear()函数中要**先减1在取模**，不然会出现-1索引值的情况
4. 如果使用数组实现，**比较好的处理方法就是设置一个头指针，一个count用于计数加了多少元素了。**这里有一个坑，就是这个count是不需要取模的，**这个是因为当count=cap+1的时候，这个时候循环队列的长度就应该是cap+1而不是1**


## 用栈实现队列
1. 这道题很有意思，和用队列实现栈不一样，这道题不能只用一个栈解决，因为栈只能操作栈顶元素，即使pop出来一个push加进去的时候也只能加在最后。
2. 这道题应该使用双栈实现，stack1用来加push元素，**stack1的结尾就是队尾**。只要遇到peek命令，就先把stack1里面的全部pop出来然后push到stack2里面，这样就能保证stack2的栈顶是队首了，**stack2的栈顶是队首**。然后每次pop的时候都要调用一下peek，然后把这个peek从stack2里面弹出去
3. 一定注意peek里面要判断stack1和stack2里面是不是同时为空，即整个队列是否为空。**以及stack2里面是否为空，不能对着空的stack2pop**



## 单调队列
### 滑动窗口最大值
这道题细节特别麻烦
1. push的时候一定要注意，remove的时候，会比较当前队尾与待加入值的大小，一定一定记住这里不能出现等于，即 value > queue.Back()，这点和单调栈是相反的，这点是为了防止有重复数字。
2. pop的时候一定要注意，只有当pop的值是当前对首的时候才需要pop，这个一定要注意，千万不能扫描整个队列，然后pop出对应的值，因为1. 可能会出现两个一样的值 2. 如果要pop的值不再队首是不合理的，因为窗口滑动的过程中，要pop的值如果在队列中的话一定是最先加入队列的，如果这个值的后面有比它大的值，它就会在前几轮被pop掉了，不可能出现在队列里面。



# 栈
### 最小栈
为了代码简洁，两个小trick：1. stack加一个，minstack就要加一个（加当前值与最小值之间最小的那一个），这样不需要if判断了。2. 在minstack里面提前加一个特别大的值。

### 有效的括号
每一次判断栈顶的时候还要判断栈里面有没有元素。最后返回的时候还要判断一下栈里面的元素是否全部排出

### 删除子字符串的最大得分
首先有两种操作，分数不一样，最终要求最大的分数，很可能就是贪心解法。
这道题处理过程特别像有效的括号里面除了括号还加了一大堆字母，但在这之前还有一个外壳，就是贪心
1. 这道题使用贪心的是因为a和b数量一定，比如去掉ab得分大，那么不可能出现去掉ab以后，还剩两个ba的情况，也就是说不去掉ab也最多只能去掉一个ba，相比之下，应该去掉ab
2. 这道题用栈，是因为会出现aaabbb的情况，即嵌套的ab，这个和有效的括号一样。
3. 出栈的时候一定要判断一下栈里还有没有元素，不然索引越界了，跟有效的括号那道题一模一样。 

### 使括号有效的最小插入
使用一个need表示右括号的需求量，res记录左括号的加入次数，最终结果是need + res

### 平衡括号字符串的最少插入次数
这里注意右括号一定需要偶数个！！！！！！，原因推过了，因为必须要在下一个左括号出现前出现偶数个右括号（0也算偶数），这是因为每一个左括号对应的两个右括号必须是连续的，也即其对应的两个右括号之间不能隔着左括号

### 函数的独占时间
1. 这道题其实就是一个有效括号的升级版本。函数记录压栈的过程就是一个典型的栈，首先要记住，他不可能交叉，既不可能`1start-2start-1end-2end`，他压栈的时候一定是匹配的。
2. 跟有效的括号一样这道题也只需要记录“start”的函数记录，不需要压“end”的记录。然后注意end对应的timeStamp要加1
3. 这道题特别容易漏的一点是，当你pop一条记录的时候（只有current记录是end的时候才需要pop栈顶）：**要把pop后的栈顶的timeStamp改成current timeStamp**，不然就会多算下一个栈顶的时间。


### 括号生成
注意这个是一道使用回溯算法的题目

## 单调栈
### 下一个更大元素/每日温度
单调栈：
框架

```
vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> res(nums.size()); // 存放答案的数组
    stack<int> s;
    // 倒着往栈里放
    for (int i = nums.size() - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.empty() && s.top() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的 next great number
        res[i] = s.empty() ? -1 : s.top();
        // 
        s.push(nums[i]);
    }
    return res;
}
```
1. 注意那个while里面第二个条件那个等于号不能少了！！！，不然就不是单调栈了，栈里面可能会有相等的元素
2. 还有注意每一个元素都要push入栈一次。

### 下一个更大元素2
这里面涉及到一个小技巧，循环数组经常用的一个小技巧：假设数组复制了一遍接在原数组的队尾（实际数组并没有复制），遍历指针从`2*len(nums)-1`开始，往前遍历，索引就是取模。这样做相当于把最后返回出去的ans数组更新了两遍，也相当于排了两次单调栈。只不过空间复杂度省下来了。

### [柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

1. 这道题的核心思想是如果当前height能确定**高度为单调stack中最后一个高度hh的矩形**的面积，什么时候能确定？那就是当遇到比hh矮的矩形（等于都不行，你细想），这也是为啥heights最后应该加一个-1，方便计算。

2. 这道题有三个点要注意，很难。**首先是单调栈中应该存下标，这样好确定矩形的宽度**。第二，当需要确定hh为高度的矩形面积时，**一定要把hh给pop出去以后，用hh前面那个下标去算，这是本题的核心，因为hh的宽度实际上是`(hh前面那个下标，当前遍历下标i)`这个开区间。**第三是如果hh给pop出去以后，单调栈空了，这个时候说明`[0,i)`都是hh，直接用`i`当宽度就行。如果要理解这一点，你用一个逆序的heights带进去试一下就知道了

   
   
   


### 用队列实现栈
这道题可以就用一个队列，每次push的时候，都把这个队列的除了push进去的这个元素的前面的所有元素都pop出来，然后加到队尾，这样队列pop的时候就是栈顶了





