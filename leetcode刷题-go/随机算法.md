# 随机算法

## 洗牌算法

## 水塘抽取算法
+ 核心思想：
  1. 水塘抽取算法的精妙之处在于它不需要知道数组的长度，可以一边添加，一边抽取，最终保证每一个抽取的元素的概率都是相等的。
  2. 水塘抽取的精髓就是在此次抽取之前的所有抽取都不作数！！！！，是否最终抽取这个数只和后面的抽取情况有关。
+ 算法内容：如果要随机选择k个数，只要在第i个元素处以k/i的概率选择该元素即可
+ 证明：
  1. 当k = 1时很简单，列个式子就可以理解了：<https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484974&idx=1&sn=795a33c338d4a5bd8d265bc7f9f63c03&chksm=9bd7f826aca07130e303d3d6f5c901b8aa00f9c3d02ffc26d45b56f1d36b538990c9eebd06a8&scene=21#wechat_redirect>
  2. 当k = 任意值，<https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484974&idx=1&sn=795a33c338d4a5bd8d265bc7f9f63c03&chksm=9bd7f826aca07130e303d3d6f5c901b8aa00f9c3d02ffc26d45b56f1d36b538990c9eebd06a8&scene=21#wechat_redirect>
  当k = 任意值时，注意一个问题就是k/i后面乘的那个实际上是"在后面的选择中不替换该元素的概率"，但其实k=任意值时并不像k=1时那样，替换概率1/i+1很直观，当k=任意值时，在i+1的时候选择那个数字的概率是k/(i+1)，但你正常是可以选k个数字的，真正要**替换**掉i时选中的那个数字的概率还要乘上1/k，这样其实跟k=1时的替换概率是一样的，这个可以理解一下k其实没有影响的。
+ 注意事项：
  1. 一定要注意当抽取到某个数的时候，不要return，不要return，不要return，一定要继续抽取等整个列表结束了以后再return，因为可能会发生替换！！！，水塘抽取的精髓就是在此次抽取之前的所有抽取都不作数！！！！，是否最终抽取这个数只和后面的抽取情况有关。


## 加权随机算法
### 传统算法
<cnblogs.com/UnGeek/p/5917995.html>

### 牛逼现代算法
<https://lotabout.me/2018/Weighted-Random-Sampling/>


### 按权重随机选择(leetcode 528)
这道题按照传统解法就可以，这道题使用前缀和就可以让每次搜索不要全部遍历一遍了。前缀和算出来以后就在上面二分搜索，使用golang内置包sort.SearchInts。
1. 注意生成的随机数一定是从1开始的！！！，因此使用golang里面的rand.Intn后要加1。不加1就会出错。
2. 二分的时候如果使用sort.Search，func里面一定要写preSum[i] >= x，注意那个x是定值，是之前randIntn的值，不能是rand.Intn，不然每次都随机取一个就出错了。除此之外


### 黑名单的随机数
1. 这道题不能使用额外空间存储[0,n)，不然会爆。所以额外空间只能用来存黑名单数的映射。黑名单的数映射到尾部去
2. 这道题最关键的就是如果尾部的数字在黑名单里面怎么办，因此要先把黑名单的数加到hashmap里面去，然后再去建立索引，遇到黑名单数只能跳过，**一定要记得用for循环跳过**，而且只要建立映射，指针也要后移一位。
3. 如果发现黑名单数已经在尾部了，随机取的时候取不到，建立hashmap的时候可以直接continue

