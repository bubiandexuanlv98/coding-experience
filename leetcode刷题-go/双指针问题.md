# 双指针解题
### 快慢指针类型
1. 快慢指针包括两种，一种是那种两个指针的移动每次的移动策略相同，比如一个移动两个一个移动一个，或者各自往前移动一个，只不过起始点不同。这种快慢指针相对来说简单一点。
2. 另一种有点费脑子，就是快慢指针实际上是，快指针在循环中前进的次数要比慢指针多，大部分情况下都是快指针每次都动，但是慢指针只在特定情况下才动。这种一般都是把快指针看成是一个”眼睛“，用来查看数组中的所有元素，慢指针是代表的是结果，一般是一个左闭右开的区间：[0,slow)，slow就是结果长度。左闭右闭的情况也有，看方便，但是这种方便的时候不多。
3. 着重讲第2种，注意在”没有意外发生前“，两个指针应该是齐头并进的，而后发生了”意外“，fast开始往前走，而slow停止，直到fast看到了解决意外的数字，接下来有两种操作：1. 然后slow和fast的值替换 2. 或者slow前进到fast的位置（同时更新解）。这里解释一下第一种情况，就是slow和fast替换，一定要注意，**一般没有意外发生的时候也走的这个判断**，因为这个判断会让slow指针前进，从而实现”齐头并进“
4. 有一种非常好用的方式去确定slow的位置：寻找循环不变量，就是起始点，循环中，结束三个阶段都不变的性质，即弄清楚slow指向的位置到底是啥含义，然后**在循环过程中要让slow始终保持这个含义，如果可以保持就一定要前进，保持不了停止**

### 移动零 & 移除元素
1. 这两道题都属于只用fast指针去比较，slow指针只参与替换，不参与比较
2. slow的含义


### 删除有序数组中的重复项1 & 2
1. 这两道题都属于fast和slow指针都要参与比较，fast和slow指针相互比较
1. 第一道题很简单，这个解决方案和“删除有序链表1”相似
2. 第二道题需要明确一下，你可以把slow作为闭区间也可以作为开区间，以开区间为例，fast和slow-2比较，为啥这样？**因为它是有序数组，这就意味着如果nums[fast] == nums[slow-2]，那么fast，slow-1，slow-2是同一个数值！！！，不满足题目要求**

### [删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

1. 这道题属于比较难的，因为它和我们一般的双指针+循环不变量有点不一样，首先slow必须是闭区间，因为单链表是单向的，slow是“没有重复的链表的最后一个节点”。**其次fast必须要在一轮循环中持续前进到当前位置和下一个位置不一样的位置**
2. 这个时候你要考虑fast的位置是“重复节点的最后一个节点”还是“slow下一个不重复节点”，如果是前者，你要`slow.Next = fast.Next`，如果是后者你要`slow = fast`
3. 这道题还要有一个dummy节点，初始的slow就是dummy节点（用来保证循环不变量的初始情况，同时这种技巧广泛用于链表头结点不一定是结果的头结点的情况）
4. 最后fast要fast.Next，但是slow不要动，slow留到2中那里动，典型例子：{1,2,2,2,2,3,3,3,4,5}，slow动了就会把3装进去


### 最长回文字符串
这道题有一个点需要注意：针对字符串中每一个字母寻找回文串的时候，**一定要有两个指针**，防止奇数长度和偶数长度的字符串不一致，**而且一定要寻找一次奇数长度的回文串，寻找一次偶数长度的回文串**

## 左右指针问题

### 接雨水

1. 这道题写出来很容易，找出某一个位置左右最大值的最小值，然后就可以求出这个位置能装多少水，可以预先找出那个“最大最小值”，然后一遍迭代就出来了

2. 但是这道题还可以用左右指针来求，某一个位置a能装多少水，完全取决于其左边最大值l_max和右边最大值r_max的最小值是多少，如果有一个left一个right，**对于left的位置而言，如果l_max < r_max，无论r_max是不是真的是右边最大的值，left位置上能乘多少水也只跟l_max有关了（是l_max-nums[left]）**，因此可以直接计算后加到最终结果中。同理对于right指针也是一样的。计算过的位置就把left或者right移动一下，直到全部算完，答案就出来了

3. 这里解释一下为啥算left的时候不能带着right也算了，因为首先可能会出现当前right的左边还有高于l_max的情况，这个还没遍历到，因此不能确定右边的right应该用哪一个值去减

   

### 找到K个最接近的元素

1. 这道题和下面那道“找出第 k 小的距离对”，题目名字很像，但是做法很不一样，二分法极其复杂，建议不要使用二分
2. 这道题核心是排除法，就是找到k个，那么就应该排除len(arr)-k个，怎么排除？就用双指针left和right，左边离x更近就排除右边的（right--）,右边离x更近就排除左边的（left++），一样近就排除右边的
3. **一定要注意：要提前判断这个值是否大于最大的或者小于最小的**

### [快乐数](https://leetcode-cn.com/problems/happy-number/)

1. 这是一道简单题但是是中等题的思考复杂度。实际上用的是链表判环的那套快慢指针的思想，**如果无限循环，一定会有一个环，这是最关键的**
2. 使用getNext计算下一个数，就相当于是在链表上往前前进了一步，可以设置一个fast，一个slow，然后开始快慢前进。

# 滑动窗口
## 计数问题
这个问题看似简单，有的时候**那种窗口内增加一个数，计数结果不只加1的情况需要注意**，这种题最好的计数方法就是想明白窗口右边界移动1位，计数值加多少。

### 乘积小于K的子数组
1. 这道题一定要注意，窗口内数据量增加1，计数值增加(right-left)（前提是right++了）。比如[1,2,3]增加一个4，就增加了[4,3,2,1]，[4,3,2]，[4,3]，[4]，这么5-1个数
2. 注意一下left指针移动的时候要有边界，始终保持left < right（循环不变量）


### 找出第 k 小的距离对
1. 这道题是二分+双指针的一道题，先排序，然后找最大差值作为right。left是0，然后二分查找，每轮寻找mid值的部分使用滑动窗口
2. 这道题在找小于差值mid的数对个数时，用滑动窗口可以在常数空间内算出结果，不要用前缀和的技术，那样空间就不是常数空间了
3. 每一次滑动窗口都是从left=0,right=0开始，和乘积小于k的子数组计算方式一样，窗口内每增加一个数，计数值增加(right-left)（这里可能不需要right++，right++是每轮循环最后的时候做的），原理和乘积小于k的子数组一样。
4. 这道题的二分也很有讲究，是找左边界，这个需要看一下二分查找


## 子数组与子串问题
这类问题首选滑动窗口
```
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

    int left = 0, right = 0;
    int valid = 0; // valid 表示窗口里面的字符串是否已经满足need的要求
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/

        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```
这是网上给的框架我认为非常nice，但是有个地方他没总结到，就是更新解的位置：
当第二个while那里的条件是“不满足”的时候，更新解的位置要放在循环外，当for那里的条件是“满足”的时候，更新解要放在循环内，这个其实是为了防止最后一个元素仍然不满足，导致没有求出最后一个解。


解题模板：
```
left, right, n := 0, 0, len(nums)
for right < n {
    // 这里（1）要通过加入右指针指向的值，增加数组空间，这里（b）可能需要更新解
    for 题目条件满足/或不满足 {
        这里通过减少左指针指向的值，减少数组空间
        这里（a）可能需要更新解
        left++
    }
    // 这里（2）要通过加入右指针指向的值，增加数组空间，这里（b）可能需要更新解
    right++
}
```
+ 解题关键在于（1）和（2）、（a）和（b）的选择。一般会放在（1），放在（2）的时候一般是因为增加数组空间需要额外判断且这个判断正好和题目条件一样，这个额外判断就会丢给内部for循环一并做了，这样可以省点代码，但实际上还是可以放在（1），加个判断即可。（a）、（b）主要看减少解空间时是否每一步都会更新解，如果需要则放在（b）不需要则放在（a）。放在（a）的时候一般是只有在条件满足才会更新解的情况下。
+ 上面这个模板是我自己总结的，其实非常冗余，可以看labuladong的模板，非常好非常好，但是有一个地方他没总结到，就是更新解的位置，当for那里的条件是“不满足”的时候，更新解的位置要放在循环外，当for那里的条件是“满足”的时候，更新解要放在循环内

### 最小覆盖子串
### 字符串的排列
1. 这道题区分最小覆盖子串，前者直接用need，不用窗口windows也可以，但这道题必须要用windows，因为并不是need全部等于0就可以了，如果过程中need消减的过程中断了（相当于被别的字母打断了）need还要恢复原样，因此need必须不能动，用于比较
2. 还有一个地方需要注意，就是那个valid的减小，必须要先判断windows里面的那个字母的个数是否等于need里面那个字母的个数，等于才valid--
3. 这道题必须用windows，但其实**维护的是一个定长的窗口**，这个可以用滑动窗口一般公式，也可以直接定长窗口移动。滑动窗口的一般公式里面windows收缩的条件就是**windows长度（right-left）**超过了定长的长度
3. 这道题的valid很有借鉴意义，他告诉我们很多时候可以用valid来统计合格的个数，而不是每移动一次窗口就要比对两个hashMap
3. 注意这道题最好不要使用提前前进left的方法，**其实right如果碰到一个need以外的字符，left是可以直接前进到right位置的（因为left到right此时已经不可能再是s1的排列了），但是前进的话valid要清0，windows也要清0，会有gc和内存申请开销**

### [最少交换次数来组合所有的 1](https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together/)

1. 这道题可以把1的个数先遍历出来，然后弄一个窗口，长度等于1的个数，算这个窗口里面0的个数就是要交换的次数。
2. 这道题其实和字符串的排列很像，因为其实这两道题都是定长的窗口，只不过上面那道题如果用定长的窗口会增加一次额外的起始扫描，所以可以不用定长窗口，边移动边计算。这道题不用定长窗口，使用滑动不定长窗口的思路和字符串排列一样

### 删除子数组的最大得分
这道题使用hashMap做窗口，如果使用int做value直接套模板就可以了（这道题和无重复字符的最长子串一样），如果使用struct{}做value其实是可以的，但是会复杂一点


### 最长湍流子数组
1. 这道题使用双指针做，非常恶心，因为它着一张滑动窗口的脸，但不完全是滑动窗口，这是因为其实你会发现，当条件不满足的时候left移动的个数是不一样的。
2. 因此要用一个if判断，条件不满足的时候两种情况下的left移动不一样
3. 这道题最好不要每一轮都right++，代码会很丑楼，前面要加很多判断，最恶心的判断是那个如果有两个数但是arr[0] == arr[1]返回的是1
4. 这道题最好right++分在不同的循环里面，把arr[left]==arr[right]单独拎出来，如果是这种情况，就要判断一下arr[right] 是否等于arr[right+1]，是的话right和left都要加1

### 存在重复元素（1，2，3）

第一题不用讲了，过于简单。
下面两道题都是滑动窗口，只不过这个滑动窗口是一个hash类型的结构，第二题是一个hashMap，第三题是一个set
第二题和第三题有一个共同要注意的点：**加入一个元素一定要放在判断之后**。同时要保证set或者map里面元素个数小于k。这个是因为如果你把新元素先加入集合中再判断，**你新加入的这个元素会对你的判断造成影响。**
第三题里面有一个set的构建，注意golang里面没有红黑树的集合，因此这个会很棘手，一般不用这个方法了。但思路依然很好，它的思路和“和为k的子数组”和“矩形区域不超过 K 的最大数值和”的思路是一样的

### 替换后的最长重复字符



## 扫描线问题

所谓扫描线问题就是假设有一条带count的线，会在区间上移动

<img src="/Users/yixia/Desktop/coding-experience/leetcode刷题-go/图片/640.webp"  style="zoom:50%"  />

如何抽象出这个扫描线？把begin和end的节点都投影到一根线上，然后假设有一个指针在这根线上行走，碰到红点就加1，碰到绿点就减1。

<img src="/Users/yixia/Desktop/coding-experience/leetcode刷题-go/图片/641.webp"  style="zoom:50%"  />

近一步抽象到代码，begin和end分别存两个数组，这两个数组都从小到大排序，用两个指针red和green，一个在begin上面，一个在end上面。碰到当前red指针比green指针代表的值小的，count就加1，red+1，**这是因为在当前绿点前面多了一个红点**。碰到当前green指针比red指针代表的值小的，count就减1，green+1，**这是因为在当前红点前面又多了一个绿点**。

### [会议室 II](https://leetcode-cn.com/problems/meeting-rooms-ii/)

这道题是一道就是一道扫描线题目，具体看上面扫描线的代码过程，然后在扫描过程中更新重合（count）的最大值