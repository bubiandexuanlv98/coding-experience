



# 前缀X问题

很多题目需要我们先计算出一个数据结构，这个结构可能是前缀和和能是差分和，方便后面计算
**注意：起始点很重要，一般前缀X数组比原数组长1，因为前缀X=0也是一个值**

# 前缀和问题
一般如果要维护一个前缀和数组，最好它的长度要是原数组长度加1，然后数组里面i到j的和就是sum[j+1] - sum[i]，sum[0] = 0

## 二维前缀和问题
处理二维的前缀和的时候一定要注意，脑子要清楚，前提如果你是左上角加到当前位置的所有的和，你想获得a行b列，到A行B列的元素之和的话，你应该使用` (preMatrix[A+1][B+1] - preMatrix[a][b])`，如果行数相等都是a，那么应该是 `(preMatrix[a][B+1] - preMatrix[a][b])`。**A行B列的前缀和是`preMatrix[A+1][B+1]`**，千万别忘了加1

### 二维区域和检索 - 矩阵不可变
1. 这道题需要计算从左上角到特定位置的所有前缀和，然后sum的时候就执行加减操作即可
2. 这道题在计算从左上角到特定位置的前缀和的时候一定要注意不要加重复了！！！！，每一行的计算时必须申请一块新的slice，用于存放每一行的前缀和，**这个前缀和只是这一行的，千万不能包含左上角到这个位置的所有元素的和，不然就重复了**。上一行的结果可以直接使用preMatrix里面的。

### 二维区域和检索 - 矩阵可变
1. 这道题除了上面那些要注意的，还要注意结构体里面要保存原数组的值，**每一次更新都要更新这个原数组**
2. 这道题的preMatrix是每一行的前缀和，不能是左上角到这个位置的，不然更新的时候不好弄
3. 更新的时候preMatrix更新位置所在行的后面几列的数据都要加上**差值**

### [元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

1. 这道题是[和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)的二维升级版本，具体思路就是把二维转换成一维的，方法就是枚举上下边界，对于每一种上下边界组合都可以压缩成一个一维数组，然后对这个一维数组求“和为target的子数组的个数”

2. 一些细节：hashmap对于每一个上下边界的组合而言是不一样的，因此当上下边界发生变化后，hashmap要完全更新。第二，每一次的压缩只是压缩一列而已，千万不要想着把行内部也压缩了。终极优化：判断一下行列谁低，枚举低的那个维度的上下边界

3. 这道题可以申请一个新的二维数组，比原来的二维数组高一维，存放0。**如果不重新申请，记住上边界要从-1开始，然后内部做一个判断**

   
### [将字符串翻转到单调递增](https://leetcode.cn/problems/flip-string-to-monotone-increasing/)
1. 这道题的核心是明白一件事，即在二进制序列中，前缀和等于前面1的个数。如果要把前面全部变成0，就要翻转“前缀和”个1
2. 单调递增有三种情况，全0，全1和01结合，其实本质上是那个01的转变发生在哪里。我们可以遍历所有位置i，其实是**遍历所有可能是01转变的位置**，**计算在这个位置及以前是0，这个位置后面全是1，所需要的翻转次数**注意，认为这个转变位置的位置上还是0会好算一点
3. 翻转前面的1成0需要`preSum[i]`次，翻转后面的0成1需要`n - i - (preSum[n] - preSum[i])`注意preSum比字符串多1个。**注意翻转的位置可能在string的0位置之前，即全1的情况**。

## 使用HashMap维护前缀X
### HashMap维护的是前缀状态第一次出现的位置
1. **这种题目一定要注意没有数据是什么状态**，它对应什么值，状态是0记录为位置0，后面的所有状态都要从1开始，所以每次写位置的时候，当前i位置上的状态应该是i+1，这就要求在计算结果的时候，是 i + 1 - hashMap[状态]，那个加1至关重要
2. 一定注意HashMap存的是前缀状态**第一次出现的位置**
3. 这种一般都是求最长的长度，或者隐含最终结果需要最长（比如连续的子数组和）


### 每个元音包含偶数次的最长子字符串（这道题非常巧妙）
1. 这道题的前缀状态是，五个字母出现的次数是奇数次还是偶数次，这个其实用二进制表示就可以，五个数相当于是0~32，这个状态是一个status，前缀和里面的sum一样，迭代过程中不断变化
2. 在统计过程中如果遇到某个元音字母，把对应位置的奇偶值改一下就行，使用异或+移位。比如要把status的第2位奇偶变化(0开始)，就使用 status ^= (1 << 2)

### 连续数组
1. 这道题的前缀状态是zero的个数减去one的个数！！！



### 连续子数组的和
1. 这道题考察的就是模运算的性质——**两个数字模同一个数字的结果相等，两个数字相减就能被这个数字整除**，所以hashMap主要用于寻找模值相等的数对应的下标
2. 这道题有一个刁钻的地方就是要求长度至少为2，这就导致你要尽可能找长度更长的子数组，这就是为啥hashMap的key存储的是前缀状态第一次出现的位置

### HashMap维护的是前缀状态的个数
1. **这种题目一定要注意没有数据是什么状态**，它对应什么值。
2. 有很多时候这个个数实际上是组合问题，可以最后用乘法算出组合，比如统计优美的子数组 & 和可被K整除的子数组，但是乘法一定能改成加法，因此都可以改成一轮遍历，每轮中遇到符合条件的直接加上



### 和为k的子数组
这道题和动态规划里面“矩形区域不超过 K 的最大数值和”的思路是一样的
+ 普通思路
1. 原思路是先整出一个前缀和数组`sum := []int{...}`，然后任取i，j相减找出符合条件的子数组，注意0也是前缀和之一。
+ 优化思路
1. 优化的方向是找出sum[j] = sum[i]-k的个数，**用一个HashMap存储每个前缀和出现的次数，key实际上是数组[0,i]的数字加起来的和**，**一边累加前缀和一边计算结果**
2. 一定要大胆假设j是大于i的，不用担心单向遍历的过程中会不会有sum[j] = sum[i]-k，j > i，但j还没遍历到。因为按照子数组的定义，只有大下标的减去小下标的前缀和才是有意义的。小下标减去大小标，本来就不是子数组

### 统计优美的子数组
+ 普通思路
1. 用一个HashMap记录，**key是子数组中（这里的子数组实际就是指[0,i]）奇数数字个数，value是拥有k个奇数数字的子数组的个数**
2. 迭代HashMap的key和value，用value**乘上**HashMap[key-k]
+ 优化思路
1. 还是用一个HashMap记录，只不过边迭代数组边记录，同时边**加上**HashMap[key-k]，注意不是乘上，因为上一种方案是全部记录完在计算个数的


### 和可被 K 整除的子数组
1. 和连续子数组的和一样，两个数字模同一个数字的结果相等，两个数字相减就能被这个数字整除。
2. 这道题要注意那个**模运算中的被除数可能是负数**，这个会导致结果出错，因此这里的模运算应该是：`mod := (sum % k + k) % k`

### [最小面积矩形](https://leetcode-cn.com/problems/minimum-area-rectangle/)

1. 这道题属于思维比较难的那种。有很多要点。第一是这道题的解决是**通过固定x，然后寻找四个对应的y**，来求最终的面积。这个需要两字段排序
2. 注意y是两个才能确定一条线，同一个x可能对应多个y，可以使用hashMap，两个y组成的key，而value是x，**在循环中发现相同的key，就可以在hashMap里面找到前面最近的x**，从而把最小面积算出来。注意那个key可以使用：40001 * y1 + y2来表示（**这个也是这道题的一个创新点，不需要存储数组！！！）**
3. 这道题最大的一个问题就是，那两个y组成的key是一个排列！！所以要找到同一个x对应的所有的y组合
