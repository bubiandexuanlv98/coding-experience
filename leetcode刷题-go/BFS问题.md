## BFS 框架

```
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```

## 图问题

### 墙与门

这个是个多源BFS的问题
一定要从门出发，而且一次性把四个门都加入队列即可，更新就正常更新。因为如果A门到某空格距离为3，且第一次到达，那么不可能有别的门离这个空格更近，因为距离所有门为2的空格在上一轮已经被遍历过了

### 滑动谜题

1. 一定要从0出发，让0去移动，而不是让别的数字移动，用字符串记录每次移动完的结果
2. 最最重要的是提前要记录好每个位置的相邻位置的坐标，用一个二维切片存储，这样无论0移动到哪个位置，都可以找到它下一个可能的移动位置。
3. visited，queue等存储结果的结构的元素一定要是string，不能是[]byte，不然会很麻烦
4. 当把0-9的int转换为byte的时候，**一定要是byte = '0' + int**


### 无向图中连通分量的数目

这道题很有教育意义，一个很重要的启发就是，什么样的入参才是BFS算法喜欢的入参？答案是，你必须能通过一个点找到所有它连接的点。

这道题的边表示法不适合BFS算法，要变成

## 抽象图问题

1. 除了正规的图问题，在算法面试和笔试中，有一些问题问我们「最短」、「最少」、「最小」，可以尝试将它们转换为求解无权图的最短路径的问题求解。
2. 这些题目有一个特征就是没有图，但是有状态转移，对于很多状态转移的问题，其实如果你能轻松的通过当前状态推出下一状态，**同时你知道终点状态**，那么往往就可以使用DFS或者BFS

### [完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

1. 这就是一道典型的非正规的图问题，把“求组成图的平方个数最少”这个点转换为求图问题
2. 这道题n作为根节点，放入queue中，每次向queue中加入`n-平方数`作为新的根节点。那个平方数一定要记得从1开始一直到`j*j < 根节点`
3. 这道题step要初始化为1，这个非常关键
4. visited主要是怕同样的组合排序不同，比如先9后3和先3后9两个应该是一个方案

### 水壶问题

这道题也是一道很有教育意义的题目，它告诉我们即使没有图也可以用BFS，只要有状态转移。对于很多状态转移的问题，其实如果你能轻松的通过当前状态推出下一状态，同时你知道终点状态，那么往往就可以使用DFS或者BFS

1. 这道题最好定义一个State的结构体，千万不要用切片（因为切片不能作为key）
2. 这道题要用一个函数把当前状态的下一状态都计算出来然后塞到一个切片里面去。具体如何转移就是题目中给的三个操作，前两个操作各对应两种转移，**最后一个操作对应四种转移，注意下一状态有8个**，
3. 但是这8个状态并不是每一个都能由当前状态转移过去。因此需要判断哪一个才是合法的下一状态（注意如果和当前状态相同也属于不合法，这是为了剪枝）。
4. 这道题的终点状态很显然是知道的，即x剩下z，或者y剩下z，或者x+y=z



### 打开转盘锁

要有一个hash表保存已经访问过的数字，确保不会重复访问某一个数字（因为之前访问过这个数字，一定说明这个转到这个数字的步数要比当前步数少）

### 