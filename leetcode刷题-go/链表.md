# 链表

## 链表创建
这里要注意的是使不使用哨兵节点的问题（单链表只需要头部哨兵，双链表需要头部哨兵和尾部哨兵），一般最好是使用，因为哨兵节点可以统一插入的操作，所谓统一操作是指两个点
1. 当链表为空和链表有值两种情况下，不需要用if语句去区分这两种情况，一套代码就可以统一链表为空和链表有值的插入操作。如果不用哨兵节点强行统一会出现使用nil指针的情况。
2. 对于单链表而言，0位置插入的情况如果没有哨兵节点就必须单列出来处理，在有了哨兵节点后也可以直接使用插入操作代为操作，把index设为0即可。对于双链表而言，0位置和末尾位置的插入没有哨兵节点就得单列出来处理，有了头部哨兵和尾部哨兵，也可以直接使用插入操作代为操作。
单链表创建的时候需要注意：链表类里面得有一个Len，一个头部节点
双链表创建的时候需要注意：链表类里面得有一个Len，一个头部节点和一个尾部节点。初始化函数里面，必须把头结点的Next设为尾结点，尾结点的Prev设为头结点。
双链表在加入，删除和查找的时候要注意：如果用的是index操作一定要判断这个index是离头部比较近还是离尾部比较近，从离得近的那一边出发。如果是用的是val值那就头部尾部同时出发。
3. 双链表加入的时候往往会有点复杂，不过要遵循一个原则，就是比如加入一个node，一定要先把这个node的prev和next设置好，再去设置它的前驱和后缀，这样才不会乱。

## 单链表与双链表比较
### 单链表双链表之间的区别
单链表只有指向下一个节点的指针，双链表还有个指向上一节点的指针，单链表只能单向读取，双链表可以双向读取

### 双链表的优势
1. 删除单链表中的某个结点时，一定要得到待删除结点的前驱，得到该前驱有两种方法，第一种方法是在定位待删除结点的同时一路保存当前结点的前驱。第二种方法是在定位到待删除结点之后，重新从单链表表头开始来定位前驱。尽管通常会采用方法一。但其实这两种方法的效率是一样的，指针的总的移动操作都会有2*i次。而如果用双向链表，则不需要定位前驱结点。因此指针总的移动操作为i次。
2. 查找时也一样，我们可以借用二分法的思路，从head（首节点）向后查找操作和last（尾节点）向前查找操作同步进行，这样双链表的效率可以提高一倍。
### 单链表的优势
单链表的优势就是存储上的优势，少存一个指针，双链表在一些时效性要求不高的应用下并不适应，因为它占用空间大于单链表所占用的空间；这时设计者就会采用以时间换空间的做法，这时一种工程总体上的衡量。所以市面上往往还是单链表多一点


## 合并两个链表类型的题目（两数之和，合并有序链表）
合并的那个新链表，要用一个指针p去引导它，将它连接起来，这里p在初始化的时候尽量用一个哨兵指针，这个会很方便。同时保留新链表的头指针（即那个哨兵指针）
两数相加的那个要注意不断的申请新的节点，不要用老节点复用。

### 重排链表

这其实也是一道合并链表的题目

注意所有链表题目，如果leetcode报错，但是找不到问题的行，都是因为运行的时候错误了，这个时候要查看整个链表中有没有该断开但是没有断开的地方

1. 快慢指针找出中点，翻转后半部分链表，再把前半部分和后半部分合并，这个合并比上面合并有序链表方便，因为就是交叉合并。注意那个后半部分是指后一个中点的Next及其后面的节点。注意最后一定要把slow.Next = nil ，不然会报错

### 奇偶链表

这个题目做一次死一次，做一次死一次
防范低级别bug：不能空指针.Next !!!!!!
防范高级别bug：不能成环 ！！！！不能成环 ！！！！！奇数链表最后一个会和偶数链表第一个成环。这个bug会让你顺利把整个函数运行完，但是leetcode内部运行的时候就会报错。这种报错有两种形式，一种是超出时间限制（因为成环了），另一种是out of memory 这个是内部报错，非常坑非常坑
解题技巧就是：一前一后两个指针（两个指针紧挨着），然后在循环里先更新奇数指针，再更新偶数指针，一定要注意这两个更新过程是对称的。

### [复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

1.  这道题很简单，直接先根据next把原链表复制一遍，**注意把origin链表节点用hash表映射到新的链表节点上去**。然后再遍历一遍原链表，然后把random的指向复制一下（借助前面的hash表）

### [分隔链表](https://leetcode-cn.com/problems/partition-list/)

这道题想清楚了也非常简单

1. 设置一个大于等于x的头结点A，一个小于x的头结点B，两个都是伪节点，然后遍历链表把大于等于x的节点接到A后面取，把小于x的节点接到B后面去

### 链表最大孪生和
1. 这道题其实很简单，但是要灵活的使用技巧，**单链表如果要从后往前遍历，必须要先反转链表**
2. 这道题就是需要反转一半的链表，然后一个指针从头开始一个指针从后开始，相向遍历，一遍遍历一遍计算和

## 链表排序类

### [对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

对链表排序有一个问题要记住：链表的特性就是插入简单，索引困难。所以什么排序方式最适合链表：插入排序

1. 这道题用插入排序要保留一个lastSorted，然后用一个cur去迭代，遇到需要插入的节点，把它从lastSorted后面删除，黏贴到待插入的位置（注意这里又有一个链表的常用操作：找到待插入位置的前序指针，才能执行插入）
2. 当lastSorted本来就小于cur的时候，可以直接进入下一轮，不用插入，这是一步剪枝
3. 伪头节点！！！！！因为头结点可能会变

## 回文链表
这个题目一定要注意，要翻转一次链表，从中间翻转。奇数个节点和偶数个节点是可以兼容的





## 反转部分链表（反转链表2）
这道题用递归很方便
1. 递归函数的意义是，返回以head为头结点的链表，返回**翻转后的链表**的头结点。先考虑全翻转的情况，翻转长度为n的链表，实际上是先翻转后n-1链表
2. 要在外面单独声明一个后继节点用来保存终点的下一个节点
3. 每一个节点的Next在每一轮中都要置为successor，但实际上回到上层函数中，这个Next会被修改，只是你必须这样写，为了统一，到最后那个函数设置的Next不会被修改

## K 个一组翻转链表
这道题应该是翻转链表里面最难的一个了，稍微有点难度的翻转链表其实都可能涉及到successor，要保存successor。
其实很简单，递归解法很容易，注意要把翻转链表的函数写出去，用普通的迭代就可以，但注意这里的翻转是有结尾的，要把结尾作为参数传入翻转函数，其实如果翻转[a, b)比[a, b]要好一点，因为[a, b)其实相当于多进一个，相当于保存了一个successor，方便后面的迭代


### LRU 缓存机制
这道题考察的东西很多，首先要实现一个哈希链表
1. 链表部分要是双链表要有Remove，RemoveFirst，AddLast，最好写一个print用于调试，注意这里的Remove是直接Remove节点，省去查询的步骤，因为hash表直接就能定位节点
2. 链表的节点要保存key和value，这是为了淘汰缓存时，方便delete哈希表中的键
3. 加入键的时候要1. 判断有没有，有的话要更改，直接返回。2. LRU的size大于链表的size，要先把前面的删掉。3. 最后才是AddLast
4. 注意put的时候，如果存在这个key，有时候还需要改节点中的value值，因此链表的Remove要返回node，RemoveFirst也要返回node，方便删除key


### 构造函数是否要返回指针？
http://cn.voidcc.com/question/p-rkwmgnby-bmg.html