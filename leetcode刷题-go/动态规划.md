# 动态规划
**注意：所有动态规划题目的所有条件下的情况，都存在状态转移，没有在循环过程中直接赋值为true或者false的那种**
**注意：先想转移，再想base case。所有动归的状态一定要是可转移的，就是首先你必须说清楚从一个状态转移到另一个状态是怎么转移的，不能真的就单纯地穷举所有状态，不考虑怎么转移。**
**注意：动态规划的状态转移的方向有这两个原则：1. 等式左边要是大问题，右边是子问题，即问题规模是逐渐变大的。2. 如果是自底向上，也就是使用动态数组的那种，一定要先看看最终答案要啥，然后一定要一点一点的向答案前进，即答案是最后转移出来的。**

## 子串/子数组/子序列
**子串和子数组是连续的，只不过前者是针对字符串而言的**
**子序列是不连续的，但是顺序不能颠倒**

## 递归动归法

## 标准动归法
1. （这个论断有问题，别看！）有一个问题就是这个动归表是从前往后打还是从后往前打，这个问题很关键。你要看当前状态的最优值是与前面有关还是与后面有关，如果与后面有关就要从后往前打，这两个东西典型的代表就是——凑零钱（从前往后）& 打家劫舍（从后往前）// 打家劫舍也可以从前往后，我现在没看到只能从后往前的，因此不能确定这个论断是否正确

  ￼￼￼￼￼￼￼
## 一维子序列问题
+ 子序列问题往往需要两层循环，因为序列是不连续的，所以要么外层循环跑，内层循环跟。要么外层跑，内层超。还有一种情况是内层外层都从头跑到尾（最长公共子序列）。

### 最长递增子序列的个数
1. 这个一定要注意就是，每一个元素为结尾的最长递增子序列的个数要单独做一个table，**因为如果你只用一个table记录每个元素做结尾时的最长递增子序列的长度的话，如果有那种长度一样且都是最长的长度的情况就覆盖掉了，并没有统计。**
2. 也就是说要对`dp_table[i] = dp_table[j]+1`这个是否成立分情况讨论。如果等于成立，**就要`len_table[i] += len_table[j]`，如果小于成立就要`len_table[i] = len_table[j]`**，注意不是+1和=1

### 最长等差数组/最长的斐波那契子序列
这两个题目要注意的是：子序列动归中，对于只涉及一个数组进行的动归，用二维数组的横纵坐标保留两个信息（这个与labuladong的那种用二维数组横纵坐标保留目标子序列头尾索引的方法是类似的），这两个信息可以是这个子序列的最后两项的索引（最长斐波那契） 或者 最后一项和公差（最长等差数组）
+ 最长斐波那契子序列
  - 这道题要首先保存一下值-下标的map，方便对最后两项相减后得到的值进行索引。
  - 这道题要注意的是以i,j为结尾那么就要求**hash\_map[nums[j]-nums[i]]得到的值小于i**，这一步一定要做，不然会多计算。你自己画个图就明白了假设0-j里面有长度为4的等差数列。这道题尽量采用外层跑，内层超的模型
  - 一定要判断一下hash\_map到底有没有`nums[j]-nums[i]`，因为hash\_map会默认返回索引0
  - **每次必须要把dp[i][j]置为2**，再进行计算，因为构成斐波那契子序列首先就需要两个数字
+ 最长等差数组
  - 这道题可以使用hashMap来做dp数组，但是速度贼几把慢，具体方法和上一题差不多，只不过键是[2]int，其中键的第一个数是i，第二个数是diff，而且不用考虑顺序问题，因为i和diff唯一确定了这个等差序列，如果i，j之间还有别的数字在这个等差列中，那么diff会不一样
  - 这道题最合理的应该是用二维dp数组存储最后一项的index和公差。但是公差有正有负，负数不能索引，**因此得把每一个公差都加上一个offset**，这个offset能确保把整个数组中任意两数之差的**最大值的相反数**变成正数，
  - 这道题还有一个注意的点是这个dp数组存储公差的那一维的长度必须是2\*offset+1，这是为了防止公差是正的



### 乘积最大子组数

1. 这道题的亮点是需要保存一个最大值，一个最小值，因为有可能出现负数，而且题目要求连续，所以当前最小值如果是负数一定要保留，因为后面再出现一个负数很有可能一下翻的比最大值还大。
2. 注意子数组和子序列的题目的区别就在于子数组是连续的（一般一层循环就够了（子序列往往需要两层）），这点很重要。**连续就意味着，如果出现了不连续就必须中断，不能保留**不能出现imax = max(imax, ...)，这种就有可能保留前一轮的imax

### 环形子数组的最大和
1. 这道题一定要清楚**总和减去最大子数组的和剩余的数组元素如果能够收尾相连一定等于最小子数组的和**，因为你但凡还剩下一个最大子数组和最小子数组合起来与整个数组差一个正数，这个正数都应该被最大子数组收进去
2. 首尾相连就保证了“剩下的最小子数组”是连续的。因此可以找到最大子数组，找到最小子数组，比较maxSum与Sum-minSum，要注意Sum-minSum=0的情况，这种说明数组里面全是负数，这种情况应该直接返回maxSum



### 圆环回到原点问题

<https://mp.weixin.qq.com/s/NZPaFsFrTybO3K3s7p7EVg>

1. 这道题很关键的地方在于找递推关系：如果有10个数，那么走n步到0的方案数=走n-1步到1的方案数+走n-1步到9的方案数，用公式表达就是`dp[i][j] = dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]`（+length是为了防止越界）

   

## 多维度单串问题

### 打家劫舍1 & 2 & 3

#### 打家劫舍1 & 2 

1. 打家劫舍的题目最好直接状态压缩，不要写数组，不然还麻烦。这里可以按照一般规律，即dp[i]是**以i结尾**的最大打劫收获。这里的状态转移就是考虑 打劫这户 & 不打劫这户 两种情况。
2. 比较有意思的地方是，`dp[i] = max(dp[i-2] + nums[i], dp[i-1])`其实`dp[i-1]`也包含了不打劫i-1户的情况，按理说不打劫i-1户就可以打劫i户，但是没关系，因为`dp[i-2]`已经计算好了不打劫i-1户获得的最大回报，取max的时候会覆盖，不会导致漏掉，可以自己试试
3. 第二道题如果连成一个环，那么分开考虑0~len(nums)-2和1~len(nums)-1两种情况并取最大值即可

#### 打家劫舍3

1. 这道题是只能按照dp(root)是**以root为起点**的最大打劫收获来定义dp，不能按照上面1中的定义，因为二叉树的链接是单向的
2. 这道题如果没有memo会超时，为什么会需要memo，参考上面第2点，也就是说，`dp[i]`（上层节点）需要`dp[i+2]`和`dp[i+1]`（下层节点），`dp[i+2]`和`dp[i+1]`已经算好了，计算`dp[i]`的时候就直接用就可以了，不然还得再算一遍。
2. 这道题的关键就是你的dp是以“从当前位置出发能打劫到的最大金额”（主要是因为二叉树有两个子节点，如果像上面那样弄，dp数组中每个元素是一个二元数组），其实计算当前节点的时候，**并不care子节点是否打劫了**，因为如果子节点没有打劫，按照max原则直接继承的孙子节点，对于当前节点而言，是无所谓的，因为当前节点的max会把孙子节点的结果覆盖住子节点的结果。


### 等差数列划分
这道题真傻逼，放在动归里面，这个很显然就是个子数组问题，滑动窗口双指针不香吗！！！！！！，不要用动态规划，傻逼玩意

### 最长有效括号
这道题难炸了妈的，用动归解真难
1. 这道题动归数组是以i结尾的串，最长有效是多长。这样的话只有)才需要判断，遇到(直接是0
2. 判断的时候其实就是判断前面是否能组成合法括号对，这必须从i-1开始判断，是否是(，如果是，就dp[i-2] + 2。如果是)就要判断，这个）有没有凑成合法对，有的话再判断它组成的这个合法对前面是不是(（这个所谓的“前面”是指：i - 1 - dp\_table[i-1]的位置），是的话就可以加上2，这个时候恶心的来了，看第3点
3. **这道题一个核心是找到一个封闭的()，如果能找到，加上这2以后，还要加上这个封闭()前面一位的dp值，这样才是最长**
4. 这道题对边界一定要小心，多判断，其中一定注意dp\_table[i-1]是有可能大于i-1的，因为可能从头到尾都是有效的，这时候dp\_table[i-1]=i了

### 最大整除子集
1. 首先这道题需要排序，这样可以保证两件事情：1. 当nums[j] % nums[i] == 0时，**也说明 j 位置的数能整除 i 前面所有能被i整除的数**。2. 不用考虑谁模谁。
2.  最终结果是得到了最长序列以后倒推的（这道题的解法可以推广到很多一维的找最长结果对应的子数组的题目，它告诉我们并不一定需要多用一个数组记录一维信息）
3. 注意的是倒推的时候是从后往前推，每往后推一个，长度要减一，不光要看是否能整除，**还要看dp数组对应位置的长度是否匹配（这是倒推的关键）**，推的时候还有更新被除数。

### 解码方法
1. 这道题是一个求方案数的问题，凡是求方案数的问题一定要注意，当前位置处如果有两种方案，那么总的方案数是`dp[i-...] * 2`或者`dp[i-...] + dp[i-...]`，这个弯一定要绕出来！！！，**不是`dp[i-...] + 2`**，为啥？是因为前面如果有4个方案，此位置有两个a,b，那么a与前面4种方案组合出四个，b与前面4个也组合出4个，这一加不久是\*2的关系了吗
2. 这道题情况比较多，这里提一个容易漏掉的点，就是当前位置有两种解码方案的情况（一种是这一个和上一个分开解，另一种是这一个和上一个合在一起解）有两种，一种是上一位是'1'，这一位应该从0到9都可以，另一种是上一位是'2'这一位只能从0到6，这两种情况都对应两种解码。
3. 这一位不是0的一种解码方案是继承自dp[i-1]的
4. 这道题一定注意要用byte

### [把数字翻译成字符串](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

1. 这道题基本和上面那道题一样，注意转成字符串以后的nums，最好从第2个数开始打表，dp数组长1位，且从2开始打，头两个直接填上就行。而且这个可以状压，两个状态就搞定了
2. 这道题有一个值得关注是：两个两位数字串之间（“10”到“99”）或者两个一位数字串之间是可以直接比的，和数字比的结果一样，但是1位数和2位数的字符串不能比。



### 只有两个键的键盘

1. 这道题的dp[i]数组代表获得i个A所需的最小操作次数
2. 这道题特殊之处在于，计算状态转移的时候并不是一次一次转移的（即每次都操作常数个操作），而是把黏贴操作一次性全部计算上，比如对于j到i，这个转移过程，就是dp[j] + i / j，它是把最后一次复制+黏贴放在一步里面转移的，次数一并计算。

### 4键键盘

1. 这道题可以用递归来解决，状态分别是当前有x个A，剪贴板里面有y个A，还剩z次
2. 但是这道题最绝的是，这道题可以看出要想获得最多的A，操作得遵循一定的顺序，（这也提了个醒，如果能看出来排列规律，可以提前排除掉很多没必要的计算）。两个规律是：要么一直按A，要么**开头连按几个`A`，然后`C-A C-C`组合再接若干`C-V`，然后再`C-A C-C`接着若干`C-V`，循环下去**
3. 根据2，就可以设置一个dp[i]表示i个操作可以获得的最多A，然后用j迭代开始C-A，C-C，C-V的位置，找出这几个位置所最终能获得的最多的A，作为dp[i]的答案。

### [单词拆分](https://leetcode-cn.com/problems/word-break/)

这道题是一道很有教育意义的题目，教育我们记忆化到底在记忆什么东西

#### 递归解法

1. 注意所有递归的记忆化都是为了一件事：**上层递归不用所有情况都进入下层递归，上层的部分情况，下层已经计算好了**。比如第一层有16种情况，第二层有15种情况，第三层有14种情况，也许第三层的14种情况，包含了第二层的8种，第一层的8种，因此第一层或第二层的那八种情况就不需要递归求解了直接返回
2. 这道题的递归就是这样，参数是一个start，代表匹配起始点，循环中迭代匹配终点，可以从起始点一直匹配到字符串末尾，循环中每成功一次就进入一次递归，当当前start有一个成功的，就记录到memo中这个start是true，如果最后全失败也记录，然后每次进入递归的时候都判断一下memo中是否已经记录了当前点（防止上层递归过多进入下层递归）

#### 动态规划解法

1. 这道题的动归依然是记录`s[:i]`是否匹配，两层循环，外层迭代起点，内层迭代终点，动归的记录可以帮助外层循环过滤掉false的起始点




## 多维度单串问题
这种问题一般要比单串问题多一个维度，但是严格上来说不是一个双串问题，因为那个维度只是在单串的基础上增加了一些信息
### 使序列递增的最小交换次数
这道题是一个动归细节很多的问题，这个细节多不是边界细节多，而是动归的情况多
1. 动归数组就是个难点，dp[i][0]和dp[i][1]分别表示，为了使第i个位置保持递增，第i个位置不交换和交换所需要的最小交换次数，这里一定要看出来交换与不交换是两种状态
2. 注意即使你觉得妈了个巴子的不交换递增的好好的，也要把状态转移了，**这是因为这种状态会出现：`[1,6,4,5]和[1,2,7,8]`**看第三位，你麻痹要是交换第三位，你就得交换第四位，总共交换了两次，但是如果你只交换了第二位，就总共只需要交换一次
3. 发生乱序时，注意不可能两个地方都发生乱序，那样就无效了，题目保证有效。这种情况下状态转移是要么交换本位置的，要么交换上一个位置的，不交换本位置的。因为题目保证有效，所以这两个肯定有一个可以，两种分别对应dp[i][1]和dp[i][0]
4. 没发生乱序的时候才是最复杂的，分为当前位置影响上一位置（当前位置交换，上一位置也得交换，为了应对`[2,6,4,5]和[1,2,7,8]`，第二位的情况，这种是没得选，只能从上一位置交换或者不交换其中一种情况直接继承），和当前位置交换不影响上一位置（这种需要**选择上一位置交换或者不交换的最小值**）
5. **最后结果肯定也是当前位置交换与不交换的最小值**

### 奇偶跳
这道题也是一个点很多的题目
1. 这道题必须预处理，**找出每一个值比它大的下一个值的索引**，不然如果动归的过程中找时间会超时。而且但这道题的预处理也很讲究，你不能让它的时间复杂度为N^2，因为这样也会超时，这个跟直接动归过程中找其实就没啥太大的区别了。
2. 这道题的预处理很讲究，是用的单调栈，**但注意单调栈里面装的不是arr中的值，而是arr的索引**，因此在构建单调栈找每一个索引的下一个奇数跳/偶数跳索引之前，**必须先按照arr中的值，把arr的索引order排序**（注意这个order要新申请一个空间存放），**找下一个偶数跳的位置时，按照arr的升序把order排序**，注意：
	sort.SliceStable(order, func(i, j int) bool {
	    return arr[order[i]] < arr[order[j]]
	}) 
	注意那个arr里面必须是用order[i]，如果你直接用i，就会有一个问题：你排过order以后，arr没变化，同样的i，j，即使动过以后，还是arr[i]\< arr[j]，这样就有可能死循环了。
3. 单调栈找的是比当前arr值的索引大的索引a，这个索引a满足其对应的值大于当前值（这个就是靠对order排序实现的）
4. 这道题的动归部分其实挺简单的，但是最恶心的是base case，这道题隐含了一个条件导致我们容易进入一个误区：第1跳可以选择跳到当前位置，但是仔细阅读题目发现，只要跳，就必须跳到大于当前位置的位置。因此“当前位置可以到达当前位置”这个base case是靠“第0条可以选择跳到当前位置“表达的，因为0是偶数，所以时间上每个点的base case是下面这样：
	`dp_table[i][0]` = 1 // 跳到这个位置是偶数步
	`dp_table[i][1]` = 0 // 跳到这个位置是奇数步

## 双串问题
+ 二维子序列问题解题模板：
- 涉及两个字符串/数组时（比如最长公共子序列），dp 数组的含义如下：
在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。
2. 只涉及一个字符串/数组时（比如本文要讲的最长回文子序列），dp 数组的含义如下：
在子数组array[i..j]中，我们要求的子序列（最长回文子序列）的长度为dp[i][j]。
+ 在明确了状态以后，会有个问题就是我们要确定dp[i][j]是由哪一个状态转移而来，即寻找上一状态，以及怎样转换。这一步最关键有三个点要注意：
  - 子序列问题的循环基本都是一个一个字母循环，每一次一定会有两个字母（或来自两个方向或来自两个字符串）比较。所以上一状态与现在状态要么某一维度差1，要么两个维度都差1。
  - 只要比较一定就会有判断，判断的结果一定是两种，yes or no，肯定有一种结果需要分情况讨论，这个情况一定是这两个参与比较的字母一个满足一个不满足，而在这个分情况讨论中，最值函数（比如max或min）就出现了。
  - 必须是计算过的，也就是这个状态必须在前几轮循环中已经计算出来，因此要考虑循环方向
+ 分析状态转移的时候一定要从中间分析，即数学归纳法的逻辑，不要从最初状态开始分析！！！！！！！
+ 最后再考虑base case
+ 所有动归转移，都有一个原则就是当前状态必须依赖已经计算过的状态，就是对于二维的动归，如果你要计算某一个维度的信息，你就不能既依赖这个维度-1的内容，又依赖这个维度+1的内容，比如：dp[i][j]不能依赖dp[i-1]的同时又依赖dp[i+1]，这个很典型的就是编辑距离那道题。

### 最长公共子序列
公共子序列：LCS
1. 为了寻找最长LCS，我们要两个字符串一个一个字母的比较，关键是不相等的情况，不相等时有三种情况，一种是a串的那个字母在LCS中，第二种是b串的那个字母在LCS中，第三种是都不在（可忽略这种）
2. dp表要注意每一个维度的长度要比字符串长度长1，方便计算，因为最一开始要计算dp[i-1][j-1]

### 编辑距离
这是一道类似于最长公共子序列的题目，两点注意
1. 跳过，插入，删除，替换这四种情况分别对应哪几种状态转移方式。比如A是主串，B是修改后的串，删除A中i处的字符对应的是`dp[i-1][j]`转换到`dp[i][j]`，**在A中i处插入B中j处的字符对应的是dp[i][j-1]转换到dp[i][j]**
2. base case 是`i=0`(`j`任意)和`j=0`(`i`任意)的值，一定注意，不是0，把dp数组的含义明确了自然就知道是哪些值了
3. 其实你插入一个字符可以是`dp[i+1][j]`，也可以是`dp[i][j-1]`，根据状态转移的原则（上面双串最后一点），我们只能选后者

### 两个字符串的删除操作
这道题和编辑距离不一样！！！，这两个一定要放在一起看一下，就明白了，妈逼的**这个是两个字符串都能删除，而编辑距离是只能编辑一个字符串**
1. 删除a串的当前位置是`dp[i-1][j]`，删除b串的当前位置是`dp[i][j-1]`

### 最长回文子序列
1. 遍历顺序是这道题的亮点，i要从n-1到0，j要从i到n-1
2. 不相等的情况和最长公共子序列的分析师一样的，一种是左边的在最长回文序列中，一种是右边的在回文序列中，第三种是都不在（可忽略）

### 两个字符串的最小ASCII删除和 && 两个字符串的删除操作
注意这两道题就是两道最长公共子序列问题，不要被吓到

### 正则表达式匹配（这道题难度爆表）

递归解法：
1. 这道题一定要先从没有\*开始想起，然后在想加上\*该怎么办
2. dp函数意义是s[i...]和p[j...]两个是否匹配
3. 这道题永远不可能对上p[j] = \* 的时候，因为每次判断都要判断p[j+1]是不是*，之后要么j位置不变，要么j+2，反正一定跳过*
4. 这道题最容易漏分析的就是即使`s[i]=p[j] || p[i] = .`，然后`p[j+1] = *`的时候，那个\*也可能只匹配0次！！！！！比如`s=bbaaa`，`p=bba*aaa`的情况。
4. 匹配一次和匹配多次从状态转移角度看是一样的，**匹配多次对于当前而言只是匹配一次**，然后交给下一次再匹配一次。**当前并不需要考虑具体匹配了多少次的问题，后面自然会找出该匹配的次数**
5. base case： i==len(s)的时候要判断p的结尾是不是“a\*b\*c\*”这样的，而j==len(p)的时候要判断i的长度是否为len(s)，这个有点难懂。


### 不同的子序列
1. 这道题非常像背包问题里面的方案数问题，t相当于是target，即需要凑成的容量，s相当于是物品集，dp[i][j]就是s[:j]中t[:i]出现的次数，特别像背包方案数问题中dp[i][j]是容量为i，有j个物品一共有多少种凑法。
2. 状态转移中，如果s[j-1] != t[i-1]，那么说明不能用s[j-1]去匹配t[:i]，因此dp[i][j] = dp[i][j-1]。如果s[j-1] = t[i-1]，说明可以用....，但是你也可以选择不用（像极了背包问题），此时的dp[i][j]应该是用与不用两种情况加起来的个数。

### 交错字符串
1. 初始化的时候**千万不能从0开始遍历dp赋值**，必须从1开始，不然会少赋值一个，dp[0][0]直接等于true

## 股票问题
### 买卖股票的最佳时期（1，2，3）
超时动归解法（递归方法）：
1. 每一层都会有个for循环，是为了穷举当前交易（卖出，买入默认是之前价格地点）是发生在哪一个位置上。相当于每一个位置上的利润依赖下一个位置，下下个位置，下下下个位置.....的买卖
2. ans可以写在内部，每一层初始值都等于0，因为每一层的收益只取决于这一层的那个for循环每次算出的值。每一层是一个最优子结构，和之后的ans没有关系
3. 最关键最关键，每一层的循环要从start+1开始，不然会无限循环（要么就每次都把价格地点设为无限大）

状态机解法：
1. 这几道题的状态机除了限定交易次数为k的，其他的都可以化简成两个状态的，不需要整个数组，但是要先在纸上用数组列一下再压缩状态。
2. i = -1的时候如果持有股票，应该设为负无穷，负无穷不能是math.MinInt64，不然会溢出，应该使用math.MinInt32。

### 限定交易次数为k的情况
1. 这道题最好不要用状态压缩，直接三维数组
1. 代表天数和交易次数的维度都要加一
2. 注意对于不同k，它的起点不一样！！！！！，可以参见下面的解释，和leetcode上面我写的注释 

### 限定交易次数为2的情况
1. 如果状态压缩的话，其实要从dp\[0]\[1][0]，dp\[0]\[1][1]，dp\[0]\[2][0]，dp\[0]\[2][1]这四个状态出发，不能从dp\[0]\[0][0]，dp\[0]\[0][1]，dp\[0]\[1][0]，dp\[0]\[1][1]，因为对于交易次数为2的情况，它的起点是dp\[0]\[2][0]，dp\[0]\[2][1]，和dp\[0]\[1][0]。而对于交易次数为1的情况，交易次数为0的情况是定死的，不会变化的，因此可以直接写进表达式里面。但是交易次数为2的情况的话它起点会变的

### 最佳买卖股票时机含冷冻期

1. 这道题有一个特别重要的点，就是我们希望`dp[i][1]`除了继承自`dp[i-1][1]`的，**还要继承自`dp[i-1][0]`中`i-1`天没有卖股票的那一部分，如果`i-1`天卖股票了，那么我们就希望不要继承它**，这个看似是个很无理的需求，因为`dp[i-1][0]`都已经计算过了，不知道`i-1`天有没有卖，反正它取的是卖与不卖中的最大值
2. 但是1中的需求其实你仔细想一想就知道，可以不继承`dp[i-1][0]`，继承`dp[i-2][0]`，因为假如`dp[i-1][0]`是没卖的结果，一定也是等于`dp[i-2][0]`的，说明继承自`dp[i-2][0]`肯定没有错。**实际上我们经常会遇到这种“继承前面某个状态的一部分”的动归，可以去看看那一部分是不是更前面某个状态的“全部”**

## 有限状态机问题
### 骑士拨号器
1. 一共有四种状态，A:{1,3,7,9}, B:{2,8}, C:{4,6}, D:{0}
2. 状态转移方程为：
	f(A,n)=f(B,n-1)+f(C,n-1)
	f(B,n)=2*f(A,n-1)
	f(C,n)=2*f(A,n-1)+f(D,n-1)
	f(D,n)=2*f(C,n-1)
3. 看上面的状态机方程，注意虽然一个状态中有多个数，但是**考虑状态转移的时候是拿这个状态中的一个数来分析的。B状态可以由A状态中的两个数转移而来，所以那里有个乘2**。
4. 这道题是一道非常好的范例，**就是求这种路径个数的题目并不一定非要用dfs，其实可以考虑每一步的新增可能性，然后通过加和求得最终结果**，这个有点像解码方法那道题，那道题本质上也是一个求路径的问题。
5. 这道题最终是需要 4 \* f(A,n) + 2 \* f(B,n)....的，因为状态转移的时候只是针对A，B，C，D状态中的一个数字而言的，最终结果要乘上这个状态的数字总数。

### 股票限定交易次数为k的情况



### [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

1. 这道题其实是下面二叉树染色的简化版，即只能连续涂1个点
2. 与二叉树染色一样，每一个节点定义两个状态，当前节点涂了很简单，只能用子节点没涂的情况计算。当前节点没涂要找下面两个节点涂或者不涂的最大值

### [二叉树染色](https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC/)

1. 这道题可以看成是一道有限状态机问题，这个状态并不是节点，而是“从这个节点往下涂几个颜色”，对于每个节点而言，状态有k+1个，即这个点不涂色，这个点及往下涂1个，涂2个.....涂k个，一般状态机的状态用切片或者map保存（map保存的AC自动机）
2. 当这个点不涂色的时候，即dp[0]应该是左边和右边涂色值最大的两个值的和。**当这个点涂色的时候，剩下i（i从1到k）个涂色的点要分到左右两边去（注意不是k个点，因为可能这个节点只能涂小于k个点）**
3. 根据上面的分析，这道题是一道典型的后序遍历的题目，为什么？**因为当前位置的状态，即涂i个色获得多少点数是不确定的，只有知道下面所有点的分数以后才能确定，所以必须先计算下面的点**



## 路径问题
### 骑士拨号器
1. 一共有四种状态，A:{1,3,7,9}, B:{2,8}, C:{4,6}, D:{0}
2. 状态转移方程为：
	f(A,n)=f(B,n-1)+f(C,n-1)
	f(B,n)=2*f(A,n-1)
	f(C,n)=2*f(A,n-1)+f(D,n-1)
	f(D,n)=2*f(C,n-1)
4. 看上面的状态机方程，注意虽然一个状态中有多个数，但是**考虑状态转移的时候是拿这个状态中的一个数来分析的。B状态可以由A状态中的两个数转移而来，所以那里有个乘2**。
5. 这道题是一道非常好的范例，**就是求这种路径个数的题目并不一定非要用dfs，其实可以考虑每一步的新增可能性，然后通过加和求得最终结果**，这个有点像解码方法那道题，那道题本质上也是一个求路径的问题。
6. 这道题最终是需要 4 \* f(A,n) + 2 \* f(B,n)....的，因为状态转移的时候只是针对A，B，C，D状态中的一个数字而言的，最终结果要乘上这个状态的数字总数。

### 摘樱桃
#### 递归解法
1. 这道题是华为笔试题的一道升级版本，他不光要过去，还要回来。这一来一回可以认为是**两个人过去**，因此递归函数的参数是两个人的坐标，一共4个
2. 这4个x1y1x2y2值可以变成3个值，因为`x1 + y1 = x2 + y2`，这个不光节省了递归函数参数的空间，还节省了记忆化搜索memo的空间
3. 这道题最最难分析的地方（包括华为我也是这里错了）是要**区分”路上没有樱桃“和”走不通“两者的区别**，因此这里把”路上没有樱桃“返回0，把”走不通“返回-1。每次在递归函数里面做选择时，如果max的结果都是-1，那说明从这个点往后走不通，然后也返回-1给上一级
4. 除了3还有一个坑是最后一个点怎么处理：按照3的那个处理方案，最后一个点一定要在每轮递归中”选择“之前返回掉，不然从最后一个点出发肯定最后选择的结果是-1。**除此之外这道题有个小trick就是最后结果一定是两个人同时到达最后一个点，所以只要判断一个人到没到达最后一个点**
5. 这道题的memo的意义更多是过滤对称情况（这个可以进一步思考思考~）
	
### 解码方法
这实际上是一个求路径数的问题

### 不同路径1 & 不同路径2
1. 对于不同路径1，**要注意递归是会超时的！！！！**，只能用动归，**这道题一定要注意动归的起始条件，i=0和j=0上都是1，表示这些位置只有一种路径可以到达**，这也是因为机器人只能向下或者向右走。
2. 对于不同路径2，要注意**如果i=0，j=0的上面有一个障碍物1，注意这个障碍物后面的都不能像不同路径1那样赋值为1了，后面都应该是0了！！！**
3. 最终结果都是加和的结果
4. 这两道题有一个启示，就是使用递归求解路径问题的时候，时间复杂度往往是指数级（即使加了memo），动归往往是乘数级，一般情况下动归快一点

### 最小路径

这个路径问题并不是计数问题，但是放在这里是为了和不同路径1与不同路径2作比较

1. 所有在二维矩阵中的路径问题都要注意一个点：**就是i=0和j=0上面的位置分别只能从左边转移而来，和只能从右面转移而来**，因此这个时候新建一个大一维度的dp数组是没有意义的，必须要在递归循环中对i=0，j=0的状态分情况讨论。

## 背包问题
1. 背包问题一般有两种形式，一种是求最值的形式，另一种是求方案数的形式，求最值的时候存在放满和放不满的情况，求方案数不存在
2. 第一种一定是要在选择中出现max或min的，第二种是把两种选择的结果相加的形式。
3. 目前没有遇到让你一定要使用前[0,i]个物品中每一个物品的，所以下面所有问题的选择都是正确的
4. 分为放满背包和不放满背包，如果是针对求最值的问题，它们的起始点不一样，要是放满背包的话，dp\_table[0][0] = 0，dp\_table[0][任意j] = math.MinMin32（这里可能是极大值，也可能是极小值，取决于求什么最值，这里设为极小值的是题目求最大值的情况）
5. 放满背包和不放满背包如果是针对求最值的问题。最终如果是没有结果，如果dp中取的是math.MinInt32，最后是math.MinInt32+某个数，反正小于0就说明没结果，如果是math.MaxInt32，最后还是math.MaxInt32
6. 放满背包和不放满背包如果是针对求方案数问题，两个其实初始化时一样的，因为如果要求放满，最后没有放满，对应的位置就是0。如果不要求放满（一般不会出现，因为如果不放满就不叫方案数了），那最后肯定是要把整个数组扫描一遍。

### 0-1 背包问题
问题描述：有n种物品，物品j的体积为v[j]，价值为w[i]，背包体积限制V。每种物品只有1个，只有选或者不选。问背包最终能放下的最多价值是多少。（注意很多时候求最值的时候并不是求最大值，比如凑硬币问题，求的是最小值。）
动归数组：dp含义是有前i种物品，背包限制为j时，背包能装下的最大价值，注意j的范围是`[0, V]`，i的范围是`[0, n]`
选择：是否选择使用当前第i中物品（但`dp[i][j]`并不代表从`[0,i]`的物品你都使用了）
	`dp[i][j] = dp[i - 1][j]` 当前物品不选
	           `dp[i - 1][j - v[i]] + w[i] `当前物品选，`j - v[i]` 要大于等于 0，如果小于0，则只能选上式

1. 空间优化的时候会把物品种类那一维去掉，因为`dp[i][j]`依赖`dp[i-1][小于j]`，但注意迭代背包体积的时候一定要从后往前迭代，**即从大到小迭代j**，不然就变成`dp[i][j]`依赖`dp[i][j-v[i]]`了，因为每一轮都会先更新j值较小的，更新完就变成`dp[i][...]`了，没法更新后面的dp`[i][...]`。
1. （第三点可能有问题重写一下）一定要注意空间优化的时候第一层循环一定要是针对物品种类的循环，因为0-1背包问题中，物品不是无限的，对于同一个target，不能出现重复的物品
2. **一定要注意空间优化的时候第一层循环一定要是针对物品种类的循环！！！这个有问题！！！，前面这句话是错误的！！！！，看目标和那道题**，这个解释也很简单，如果你把对物品的循环放在最后，就彻底废了。因为看上面那个代码，`dp[i][j]`依赖的是`dp[i-1][j]`和`dp[i - 1][j - v[i]]`，你如果把针对物品的循环放在最后，同时你的背包限制还得从大到小迭代，你在计算`dp[i][j]`的时候只计算了`dp[i-1`][x > j] 的内容，根本没有计算`dp[i-1][j-v[i]]`
3. 背包体积从大到小迭代的时候要注意，要求`j-v[i]`要大于等于 0，这样的话，只需要从大迭代到`j-v[i]`即可，**不需要迭代到0**
4. 注意如果用二维dp数组，那么迭代背包体积的时候必须从大到0，因为你要并不从0开始，j\< v[i]的dp[i][j]就全都是0了。不能像第4条那样，那是针对一维dp数组而言的。


### 盈利计划
这道题是一个求方案数的问题，但是与其他的求方案数的问题不同的地方在于，它是有下限的，而这个下限就是背包的价值。注意大部分求方案数的问题其实都没有涉及到背包的价值，都只涉及到背包的体积。但这道题涉及到了。
1. 这道题的状态是项目个数i，人员总数j和**利润至少k**，dp数组含义是方案数。一定要注意“利润至少为k”也是状态，经常动归的题目你感觉需要在动归数组的结果中多记录一维信息，这维信息用于计算，排除不符合条件的解，**但是这种一般都进入误区了**，其实这一维信息都是没有必要的，你只需要动归数组多一维就可以了，相当于多记录一个状态。
2. 空间优化的时候去除掉项目个数，然后如果当前物品利润大于minProfit，就当利润状态`k=0`（因为是至少利润），所有至少利润为0的方案数都是1，（至少利润为0说明什么都不做也行。）

### 完全背包问题
问题描述：有n种物品，物品j的体积为v[j]，价值为w[i]，背包体积限制V。每种物品只有无限个，只有选或者不选。问背包最终能放下的最多价值是多少。
动归数组：dp含义是有前i种物品，背包限制为`j`时，背包能装下的最大价值，注意`j`的范围是`[0, V]`，`i`的范围是`[0, n]`
选择：是否选择使用当前第i中物品（但`dp[i][j]`并不代表从`[0,i]`的物品你都使用了）
	`dp[i][j] = dp[i - 1][j] `当前物品不选
	           `dp[i][j - v[i]] + w[i] `当前物品选，`j - v[i] `要大于等于 0

1. 注意上式中第二行那个`dp[i][j - v[i]]`，和0-1背包不同，这个的原因是物品是可以重复的，`j - v[i]`也有可能是由物品i组成的。所以后面会讲完全背包求最值，外层循环是背包体积，而内层循环是针对当前这个体积，是否使用物品`i`，不代表以前`j - v[i]`的体积的时候不使用物品`i`

2. 空间优化的时候会把物品种类那一维去掉，因为`dp[i][j]`依赖`dp[i][小于j]`，所以这个迭代顺序和0-1背包问题相反，**即从小到大迭代j**。因为每一轮都会先更新j值较小的，而实际上`dp[i][j]`**依赖的就是新更新的**，所以从小到大迭代j正好满足

3. 空间优化的时候要注意第一层循环是不一定的。如果是求最值，则第一层一定是针对背包体积的循环，如果是求方案数则有可能是针对物品种类的循环，也有可能是针对背包体积的迭代。求方案数分为考虑顺序和并不考虑顺序。
   + 如果不考虑顺序，即不同顺序，相同种类算同一种方案，第一层应该是针对物品种类的迭代。这种思维就是最外层的一次循环内针对所有容量的背包**考虑第i种物品加还是不加**，下一次循环就不会再考虑第i个物品加还是不加了。小trick：内层循环可以从`v[i]`开始到最大，而不是从0开始
   
   + 但是如果是考虑顺序的，即不同顺序，种类相同算作不同的方案。就需要第一层针对背包体积进行迭代，这种思维也很简单，就是相当于第一层循环，一次循环结束以后相当于**这个体积i的方案数是考虑了所有的物品种类的**，下一个循环仍然是把所有物品种类过一遍，每一轮可能都会加入与前几轮相同的物品。
   + 第一种典型题目是：凑零钱，第二种典型题目是凑零钱2和组合总和4
   + 要注意上面考虑顺序的情况是在完全背包下面的，**如果是0-1背包，考虑顺序的情况会很少**，如果0-1背包下考虑顺序就必须增加数据结构，记录每次添加的数字，同时第一层得是针对背包体积的迭代，干脆用递归算了。
   
   + 考虑顺序的那种多说一句：外层循环是重量j，对于每轮的j，第一行那个当前物品不选，**他指的是在当前重量j下不选i物品，但是这个j的组成里面可能会有i**，
     
   
4. 要注意上面考虑顺序的情况是在完全背包下面的，**如果是0-1背包，考虑顺序的情况会很少**，如果0-1背包下考虑顺序就必须增加数据结构，记录每次添加的数字，同时第一层得是针对背包体积的迭代，干脆用递归算了。

   

### 最后一块石头的重量1 & 2
这两道题放在一块说，重点说一下为啥第2道题能转化成0-1背包问题
1. **第一道题只能用heap来解决，不要想着分两堆！！！！**，因为和第二道题不同，第一道题的+堆里面的数字每一轮都大于-堆里面的数字，所以不可能经过所有的粉碎以后留在+堆里面的小石子都能安然无恙的留到最后。
2. 第二道题牛逼就牛逼在它求得是最终的最小值，+堆和-堆是可以按照情况随意放置的。你可以组合+堆和-堆，让每一轮粉碎后残存的小石子，分别分布在+堆和-堆中，这样就能让他们再粉碎一次。因此一定存在一个最终的+堆和-堆：[https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/][1] 这个解释最好，怎么样分最好呢，肯定是让 正堆 \>= 和 的一半，负堆 \<= 和 的一半，因此背包体积设为一半即可，凑负堆

### 目标和
1. 这道题可以用动态规划，但是需要想想，它和最后一块石头的重量那道题的思路一样，一定要把所有的数字分为两堆，分成+堆和-堆，目的就是把让这两堆对着粉碎，只不过剩下的必须是target，假设+堆总数是a，-堆总数是b，a-b=target, a+b=总和，求a和b，很简单凑a或者凑b都可以，转换成0-1规划
2. 这道题最大的坑在于，**如果最后除以2的那个被除数是奇数，这道题无解返回0**


### 分割等和子集
状态压缩是个难点，为啥是从后往前才行，从前往后就不行了呢？
1. 相当于是target = 总和/2，凑出一个集合即可，转换为0-1背包问题
2. target是0的时候，任何集合都能凑出这个子集，因此`dp[target=0][任何物品]` = true
3. 判断当前target是否小于当前数字其实是一个处理越界的过程，当target**小于**当前数字（注意不是小于等于！），就做出”不放入“的选择，即等于`dp[当前target][上一个物品]`


## 高楼扔鸡蛋问题
### 传统动归解法
这道题目点太多了
1. 首先，题目里面说”要确定f确切的值的最小操作次数“，其实是在问你最坏情况下至少要操作多少次。这道题目的”最坏“实际是指当搜索区间穷尽时，**或者到最后不得不线性搜索时**。至少指的是在前面这种情况下操作次数最少，所以这道题目实际上是：res = min(res, max(..., ...))
2. 这道题的状态是在鸡蛋个数和**选择哪一层楼，具体选择是选在哪一层楼扔**，和之前那个背包问题把楼层数（背包问题里面是背包容量）缩小的方式不一样，因为只有前面说的那个状态才能转移，把楼层缩小的那种状态你不知道怎么转移。2个鸡蛋2层楼变3层楼或者4层楼或者whatever楼，你不知道怎么转的。相反选择一层楼以后，就可以把问题缩小成两个子问题，状态转移自然就来了。
3. **这道题不能使用动归数组**，因为你会发现这个状态转移并不是单向的，而是双向的，解决一个状态你得又知道前面的状态又知道后面的状态。
4. 这道题的base case很诡异，除了楼层穷尽，线性搜索是这道题的base case，**即当鸡蛋只有一个时，它的base case可以直接返回楼层数！！！！！！**
5. 每一层递归里面都有一个循环选择哪一层楼实验，循环内部：res = min(res, max(helper(i-1, t-1), helper(m-i, t)) + 1)，注意那个第二个函数的第一个参数，一定要注意向上搜索时是不包含当前楼层i的，具体解释见题目。

### 二分优化解法
二分做这道题的时候，用的是等于模板，left永远是1，right是递归函数的楼层参数。二分法用来找山谷点（因为dp函数不是连续的，所以可能没有相交点）
1. 在每一个递归函数中的循环中，其实是在线性搜索楼层，这种情况找一个合适的点，这种我们就可以联想到二分法，但使用二分法有两种情况，1. 搜索空间有序，即每一个楼层对应的结果是单调递增的。2. 找谷点问题。显然这个题目属于后者
2. 在每一个递归函数中的循环中，变的是楼层数（因为每一层循环都在选择楼层），因此我们可以将每一层循环的操作都看成是找这个函数：max(dp(楼层数-1, 鸡蛋数-1), dp(m-楼层数, 鸡蛋数))+1的最小值（注意那个m是本层函数的楼层实参），而这个函数图像是可以画出来的，max里面的第一个函数是一个随着楼层数单调递增的，第二个函数是....单调递减的，因此就是”找谷点“问题
3. 第一个要注意的是上一点中的那个m，**千万不能写成总楼层数n！！！！！**，**那个m是当前函数的楼层实参！！！！**
4. 第二点是极有可能没有dp(楼层数-1, 鸡蛋数-1)==dp(m-楼层数, 鸡蛋数)的情况，因此只有 前者\>后者 和 前者\<=后者 两种情况，因为可能没有交点，所以 前者=后者 和 前者\<后者 放在一块处理，都是把边界缩小（你也可以反过来，和 前者\>后者 放在一块处理）。同时每次都必须求一次res = min(res, ...))
5. 每一层函数都要先把res设为最大，再一步步减小


## 博弈问题
### 预测赢家
1. 这道题的状态是本轮i到j的piles，这点挺像最长回文子序列的，和本轮轮的先手和后手。因此状态是i，j和先手后手用`dp_table := [][][2]int{}`来存储
2. 选择是选择左边还是选择右边
3. 状态转移一定要从小规模到大规模，因此每一轮的i,j实际上是越来越大的。
4. 一定要注意后手实际上是不存在选择的，先手直接决定了后手。因为先手后手是交替进行的，因此这一轮的后手实际上是上一轮的先手（同理这一轮的先手是上一轮的后手）。但是这一轮的先手会决定这一轮的后手继承哪一轮的先手：
	if 这一轮的先手选择左边:
	  这一轮的后手(dp_table[i][j].sec) = dp_table[i+1][j].fir
	if 这一轮的先手选择右边：
	  这一轮的先手 = dp_table[i][j-1].fir

## 二进制状态压缩

+ 有用的位运算

	1. 最低位的 1 变为 0 ：`n &= (n - 1)`
	1. 最低位的 1：`A & (-A)`
	1. 最高位的1要靠不断的寻找最低位的1然后减到最高位



## 旅行商问题
1. 所有旅行商问题一定要注意，dp[chosen][i]表示，chosen的状态下（包括i），i作为最后一个选中的位置，所积累长度的最值。一定注意第二维表示的，一定是“最后的位置”，而不是“起始的位置”，即每一轮，i都应该是终点，迭代chosen中的每一位，作为起点，往i跳，这样能得到对于针对chosen的到i的最值。
2. 一般旅行商问题可以固定终点，迭代起点，针对每个起点chosen要把终点拿掉，再进行状态转移
### 最短超级串
这道题史诗级难题，每一步都不能错
凡是遇到要回溯所有路径的，必须要用一个parent用来保存当前位置的上一个位置是哪一个位置，在旅行商问题中，parent是parent[chosen][i]，除了当前位置i以外，还要记录chosen（包含i的）
1. 这道题的重叠部分的计算很讲究，注意两个串的前后缀重叠部分，计数的时候count不能从0开始，不然你那样就变成计算轴对称的个数了，一定要从count最大的值开始往后迭代，一步步count--
3. 如果i表示下一轮的起始位置，每轮计算中都选与i最短的或最长的，就变成贪心了，每轮只选局部最优解。
4. 这道题的parent数组是一个关键，parent每个位置在赋值前要先置为-1，这个是因为如果最终parent[chosen][i]无法被赋值，说明对于当前chosen而言，所有已选中的j跳到i的重叠都是一样的，这也说明这个chosen，如果最后一个选择的是i，那么**这个chosen的所有选中（包括i本身）的先后顺序不重要！！！！**，就随意排列就行。
5. 这道题根据parent构建最终结果的过程也非常恶心，因为parent保存的是每一个位置的上一个位置，因此是倒序的。用一个循环把所有位置迭代出来，当迭代出-1的时候（见4）停止，说明剩下的字符串可以以任意顺序组合。一定要记住进这个循环的时候要先把`temp := parent[chosen][maxIndex]`保存起来，因为chosen要依据当前maxIndex变，maxIndex也需要依赖当前chosen和当前maxIndex变，因此必须要先把temp保存起来，等把chosen更新过以后在赋值maxIndex。
6. 在迭代所有位置的时候，还要用一个seen的bool数组保存所有已经被迭代出来的位置，这样当迭代出-1，循环结束的时候可以吧seen中剩下为false的位置记录下来，然后用于最后的恢复

### 优美的排列
这道题不是传统的旅行商问题
1. `dp[i][chosen]`表示当前位置i（注意这里的位置不是指传统旅行商问题中的“可选择的数字或终点”，而是perm数组的当前位置），此时已经选了chosen（包括i），能组成的优美排列的数量，因此状态转移
2. 这道题牛逼就牛逼在如果n=4，凑两个元素的perm一定比凑三个数的perm方案多，但是这个是反直觉的，其实凑三个的方案只能继承于能让第三个数符合条件的前两位的方案个数，并不是所有前两位的方案都用。你第三位只能是3，因此你在凑前面只有两个元素的perm，只有不包含3这个数字的凑法（体现在state里面）的个数才会被统计


### 贴纸拼词
这道题应该说是最优美的一道旅行商问题了。
1. 这道题核心就是你要把target上面每一位都看成是0和1，即使有好几位上面字母是一样的，不用统计，直接对应位置看成0-1状态即可，你不要想着用什么8进制或16进制。因为写代码的时候会遍历target的每一位。
2. dp数组就一维，就是target的二进制状态。含义就是凑成i状态，最小需要多少贴纸。
3. 这道题有一个技巧必不可少，就是你得先统计每一个stickers它各个字母有多少个，注意第二维最好用数组array，这样方便第5步值传递。
4. 对每一个i，你先要遍历它的上一个last有哪些，这时你就需要遍历所有的tickers，找出上一个状态，然后从而找出从上一个状态，注意对于每一个sticker，它的i都是原来的i，千万不要把i写在第一层循环
5. 第一层是i，第二层是sticker，第三层是target的每一位，注意遍历第三层之前要**值保存一下当前sticker各个字母有多少个**，因为在遍历target的时候需要减当前sticker里面的字母个数，但这个减的结果不能影响下次循环


### 不同路径3
1. 这道题也是一个教训，一定要注意，并不是所有的二维的旅行商问题都得先拉平再用一维数组去做memo，**二维数组一样可以做memo**。这道题如果把二维拉成一维，代码会变得非常丑陋且不易debug
2. 所有使用递归方法解决旅行商问题的，在对chosen进行处理时一定要注意要问自己一个问题：当前位置是不是已经在chosen里面了，**尤其注意当对chosen的判断在里面的那个循环之外的时候，这个时候特别容易犯错**

[1]:	https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/

## 计数问题

### 所有的路径问题基本都是计数问题

### 卡特兰数问题

1. 所有卡特兰数问题都不要用那个通项公式，那个太难记了。可以直接使用动归数组解决
2. 卡特兰数针对的问题有一个明显的特征，**不考虑一个集合内有哪些点，而是考虑一个集合内有几个点**
3. 卡特兰数针对的问题的计算形式一般是：f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0)，不一定从0到n-1，有可能是每隔两个或者隔三个，比如“不想交的握手”

### 不想交的握手

1. 这道题思路非常难，代码极其简单，原因在于，**这道题从代码角度看是针对点在迭代，而这道题实际上是针对分割线在迭代**。
2. 这道题外层循环和所有一维子序列问题一样，是针对num_people 总人数进行迭代，dp_table[i]表示一共有i个人，握手方案数是多少。
3. 内层循环是在外层 i 的限制下，**迭代 点 1 和 点 j 的连线，每条连线把所有人分成两个集合**，一个是 j-1-1 个人的集合，还有一个是 i - j 个人的集合，这两个人数对应的握手方案数相乘，得到的就是 i 个人的握手方案数。**为什么只需要计算 点 1 和 点 j ，然后加和就是结果？是本题的关键**
4. 上一题的问题是因为 所有的case，都是分别对应着不同的点1 和 点j，当把点1 和点j 确定好了以后，剩下的变化都是在之前计算过的，特定个数下的握手方案个数。



### 栅栏涂色

这道题和奇偶跳有点像

二维dp，第二维表示与上一位相同还是与上一位不同。其中dp[0][0\] = 0, dp[0\][1\]=1



## 分组问题

这类问题的通用问法就是把n个东西分成m组，然后求一个最值。一般m<n且分出来的组必须是连续的。比如把一个数组分成若干块求一个最值，或者把m分给n个东西求一个最值。这类问题全是难题。如果使用动态规划解决这类问题，统一方法是：

1. 使用一个二维数组，第一维度是n，代表多少个东西。第二维度是m，代表分成多少组。然后**每轮动归（即两层迭代以后）中状态转移方程中：是讨论最后一组的范围，上一状态一般是指除去最后一组后的上一状态。**
2. **千万不要去纠结“没意义的”值，动归的迭代直接从有意义的值开始迭代**。比如对于数组分组问题，不要去考虑“分0组”和“数组长度为0”的情况。**而且一般情况下分1组的情况是可以直接算出来的，这个可以直接作为初始值**。所以迭代应该从数组长度为1，分2组开始
3. 注意在讨论最后一组的范围的时候，**一定要考虑这个最后一组的范围不能使得上一状态中m>n了**这个实际上是一个“剪枝”的过程。 一般讨论最后一组范围实际上是通过讨论最后一组的第一个数的起始坐标来实现的
4. 如果求最小值，一定要在每轮递归中开始讨论之前把值先置为max

### 分割数组的最大值

1. 这道题要先把数组各个切片分成1组的值算出来，即算出来前缀和，所有的分组问题一般都是这个套路，先计算一个特殊的值，**这个值不光用来讨论“最后一组范围”的，也是用做初始值。**
2. 讨论最后一组范围的时候，一般使用j，j在这类题目中一般是指最后一组的第一个数，因此要求j-1的大小不能>=迭代的分组个数。这道题在应用上面第三点的时候要注意，j是最低到t，而不是到t-1，j到t-1就说明前面只剩下t-2个值了（因为前缀和数组中0位置的数是没有意义的（相当于数组长度为0）），但是要分成t-1组，不合理。
3. 这道题的第二点和[ 安排邮筒](https://leetcode-cn.com/problems/allocate-mailboxes/)不同

### [抛掷硬币](https://leetcode-cn.com/problems/toss-strange-coins/)

1. 这道题是一道分组问题，因为你可以这样理解：把target个正面朝上的情况分到len(prob)中去。但是这道题要注意一个问题就是：**所有硬币都要抛掷的问题**因为所有的硬币都要抛掷，所以target = 0的情况应该被提前计算出来。
2. dp_table 的第一维度是硬币个数i，第二维度是正面个数j，j = 0的情况应该提前计算出来方便转移。注意dp_table[0]\[0]应该是1，这是一个必然事件
3. 这道题在转移的时候注意，其他题目如果当前位置的硬币没被选中就直接加上就行了，这道题当前硬币如果没被选中还要乘上(1 - prob[i])，再加上去

## 区间动态规划

### [奇怪的打印机](https://leetcode-cn.com/problems/strange-printer/)

### [戳气球](https://leetcode-cn.com/problems/burst-balloons/)

1. 这道题的状态定义有一点不同，就是之前说 i 到 j 的都是闭区间，这道题的 i 到 j 是指开区间。这是因为这道题戳破第 i 个气球，涉及到 i - 1和 i + 1，如果是闭区间，势必无法分割子问题，然后使得子问题互相独立了
2. 为了让子问题互相独立，这道题的“选择”也很讲究，其实每次如果想不出如何选择，可以先想一下如何用DFS解决，DFS的选择是什么样的，那么DP就应该和它反过来。这个问题的选择是“**最后一个选择**第k个气球戳破"，因为这个选择可以让子问题独立，而且计算这个选择带来的增量的时候，不用考虑出现因为中间一个数被删掉而导致计算剩余数的时候出现“不间隔”情况。