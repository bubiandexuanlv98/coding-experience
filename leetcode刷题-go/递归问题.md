## 递归问题
首先要看一道题有没有递归性质，递归性质就是指原问题和子问题有着相同的结构，同时子问题的规模要比原问题小

递归问题就是二叉树的遍历问题，对于前序和后序遍历，我们要清楚得是：这个问题是必须得分到最小单元才能解决，还是在问题不断缩小的过程中每解决一点就缩小一点。



## 递归常见错误

1. 如果递归出现该遍历的没遍历到，可以检查一下几个终止条件的顺序（包括失败/成功的终止条件相对顺序）

## 回溯算法（DFS）
框架：
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
1. 回溯算法就是确定三个东西：路径，选择列表，结束条件。就是一个多叉树的前序遍历+后序遍历。那个做选择类似于前序遍历，撤销选择类似于后序遍历
2. backtrack的函数形参中：有时候”选择列表“永远是给全的，然后每次再做选择的时候用”已选过的“去过滤选择列表。有时候选择列表是全量，但回溯函数会多加一个index去标识，因为每次只能选index后的。如果不是每次只能选择某一个数字后面的，大概率是选用前者的模板
3. 一个小知识：计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数 // 这句话也有问题，时间复杂度讨论内容暂缓
4. 统一一下：选择列表在任何时候都只有一个，通过不断加入-撤销更改这个列表，需要加入最终结果的时候再用copy
5. 加入和撤销一定要在同一个地方，不能在这一轮加入下一轮撤销或者上一轮撤销。

### 注意
1. 注意leetcode上面刷题的时候不能使用全局变量，用go刷的时候一定要注意，如果你想把额外的backtrack函数写在外面，要么你把结果当参数传进去，要么你把结果当return返回出去。
2. 如果你需要把结果当参数传进去，这时候一定要注意结果切片一定要是以切片指针的形式传进去的！！！！
3. 综上，如果需要额外的backtrack函数，最好把函数写在函数里面，不要写到外面

### 全排列 
这道题你麻痹要注意数组的引用传递的问题，你把记录路径的数组传给一个函数，这个函数修改了这个数组会把函数外面的那个数组也改了！！！！

### 电话号码的字母组合
这道题要注意backtrack函数参数里面要传一个index，指示digit第几位，每一轮的选择列表是digit[index]

### 子集
这道题是下一道题，划分相等子集的基础。这道”找子集“其实就是思考如何用DFS去列举出”如果你有n个数，把这n个数放到一个桶里面，一共有多少种放法“。这里贴出函数：
```
backtrack = func(nums []int, start int, track []int) {
    // fmt.Printf("%v\n", track)
    addTrack := make([]int, len(track))
    copy(addTrack, track)
    res = append(res, addTrack)
    for i := start; i < n; i++ {
        track = append(track, nums[i])
        backtrack(nums, i+1, track)
        track = track[:len(track)-1]
    }
}
```
注意这是一个典型的”选择列表是全量，但回溯函数会多加一个index去标识，因为每次只能选index后的“，这种回溯非常完美的避开了讨论这个桶里面放多少个数字的问题，我们不再需要按照放不同个数字分情况讨论。
（这个点待定）有个很有趣的点就是，这道题的时间复杂度事实上是O(2^n)，因为每一个数字都有放和不放两种

### 划分为k个相等的子集
这道题从数字出发，每次选桶，这个思路非常简单，顺着写就行，三个trick：1. 把每个桶要装的和提前先算一个target出来。2. 提前判断有些情况肯定不可能均分 3. 数组先排序，然后再backtrack函数里面那个for循环里面加入剪枝条件，剪枝条件就是如果当前桶的和加入一个新的值大于target，就continue掉

### [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

1. 这道题其实是一道划分子集的问题，划分成4个子集，但是它比划分子集简单，因为它是连续的，划分子集可以不连续。用回溯最合理

### [至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

1. 这道题是一道递归的题目，但是第一眼上去是一个滑动窗口的题目，但是会发现无法确定窗口缩减的条件
2. 这道题的递归非常有讲究，它直接用当前函数就可以，每一轮要新申请一个hashMap（不要担心资源，这道题给的时间很大），去记录s里面各个字符出现频率，然后遍历，注意前方高能！！！遍历的时候**发现有个数小于k的就说明，当前s中所有带k的子串都不行**，假设c的出现频率小于k，那么要split(s, c)，然后再依次对结果字符串数组的每一项递归。
3. 更高能的是它的剪枝，**它这道题很像子集问题，子串和子集本来就是兄弟**，对于每一轮递归其实只要找到第一个频率小于k的就可以了，更高能的是**找到第一个，递归算出结果以后就可以返回了**，这个和子集不太一样，这是因为**后面几个小于k的会在递归中被找到并计算，不需要在每一轮都计算所有小于k的字符split后的结果**

### N皇后
1. backtrack过程中，必须使用[]byte数组，而不是string类型。
2. 决策树的每一层就相当于是递归的每一层，决策树的每一层就是每一行，**因此每进入一层递归，行数加1，选择就是这一行的所有列**
3. 撤销选择，就是把那个位置的值置为'.'

### [解数独](https://leetcode-cn.com/problems/sudoku-solver/)

1. 这道题作为一道大模拟题，首先有个问题就是它每行每列都可以填数字，每填一个数都会影响到下一个位置。这一点和N皇后很不一样，因为N皇后每一行只用填一个，所以每轮递归都需要遍历列。而解数独每一轮递归不能迭代行和列，只能通过递归参数去进行行和列的递归。这也涉及到递归的原则之一了，**即每一轮递归中如果有循环，那么循环里的选择（但这个选择肯定影响后序迭代）必须是相互独立的**
2. 这道题还有一个技巧就是使用状态压缩，用9个1来表示在行，列，九宫格里面各个数字的使用情况，这样就不用使用一个长度为9的bool数组区表示相应的使用情况了

### 遍历二叉树
用栈的方法遍历二叉树，三种遍历事实上是可以统一的，注意几点即可
1. 外层循环的条件里面加上root != nil 
2. 外层循环一进去就是第二层循环。前序和后序都在二层循环里面加入值，中序在外层循环里面
3. 后序是前序反过来，然后最后reverse一下结果就行

## NSum问题
### 三数之和/四数之和
1. 递归到两数之和的时候开始用左右指针，注意找到合适的数字加进去以后要把选择撤销，以满足哪里加入哪里撤销的原则。注意这里要撤销两个，因为会把两个数都加进去。
2. 有一个剪枝处理就是，**每轮递归选定数字那里，最后一定要保证最后剩下的数字个数大于count-1**
3. 这道题有三个可以加速的地方，**就是无论是前面选定数字的时候还是后面左右指针查找的时候，都可能会出现重复数字，这个时候要把重复数字去掉**，就要把指针向前移动或者向后移动。
4. 在对于选定数字那里的加速处理，要注意跟左右指针那里的加速处理不一样，选定数字那里可以直接加速到最后一个数字，这样正好剪枝了

### 最接近的三数之和
这道题和上一道题差不多，用减法去找，找到能把target剪到最小的三个数，即使target经过减法后的ans变成最小。


## 岛屿问题
岛屿问题普遍可以不用记录visited数组，直接floodhill，把遍历过的岛屿都淹了，然后继续遍历的时候就不会遍历到之前遍历过的地方了。
### 统计封闭岛屿的数目
1. 这道题要有预处理，先把靠边的岛屿都淹了，然后遍历的时候直接从(1, 1)遍历到(m-1, n-1)，这样总的遍历个数没变，效率依旧很高



## 图问题
### 所有可能的路径

这道题有一个所有图问题在应用递归算法时需要注意的问题：每一个结果中的节点的加入和删除是放在循环外面的，这点和递归的模板不同，两者区别只是是否加入了根节点的问题，因为递归一般不关注节点只关注边。而图需要把根节点加入到最终的结果中

### 课程表1

1. 首先解释一下onPath和visited这两个常用数组什么意思：visited标定已经访问过的节点即标记所有经过的点，而onPath标定一条路径从头走到尾，即**只标记一条路径**，从字面意思上可以意识到，visited是访问过就置为true，而onPath是走完以后要撤销的（对应位置置false），因为走别的路径onPath要重新标记
2. 如果走的过程中发现当前节点在onPath里面是true，说明这条路径上面有环，即说明图上面有环


### 课程表2
1. 为什么说图的拓扑排序是图的后序遍历+反转，因为首先后序遍历可以保证一件事情，即**所有的节点，一定会在它的后序节点都遍历到以后再加入结果**，这样反转过来就能保证**所有的节点，它的所有前序节点都会出现在这个节点前面**，比如1 -> 2，1 -> 4，4 -> 2，从1开始的后序遍历能保证，最终结果2一定在1，4前面，反转以后，1，4一定会在2的前面，从而实现拓扑排序。**但是如果前序遍历，2会先于4被遍历到**

2. 注意那个反转是指最后再反转，为了防止后面依赖前面的，因为假如前面的真的没有依赖，那么放前放后无所谓的。但是万一后面依赖前面的，你前面的就不能放前面了

3. 这道题有一个小trick，可以省去反转的那一步，就是如果你把那个课程表1中的建图过程反过来，把课程a作为父节点，课程a的依赖（a是任意一门课程）作为子节点，直接后序遍历的结果就是最终结果。因为后序遍历保证最终结果一定让a依赖的课程出现在课程a之前。

4. 这道题一定要注意，如果成环就直接返回nil，判断成环的代码不用单独写出来

   




### 骑士拨号器
这道题和安卓手势解锁那道题都是递归问题中的记路线个数的问题。这种题目，在递归处理中只有满足一定长度的才可以计数。
1. 先把所有数字的“相邻数字”写到一个二维切片里面
2. 这道题一定注意要把统计个数ans作为返回值返回（注意千万不要把ans放在递归函数外面！！！），**每轮循环中要把ans := 0**。每递归一层长度减1，**减为0的时候，return 1，千万记住不是return ans。**，最后要把ans return出去。
3. 注意**每次对计算ans的时候，结果都要取模**，不然最后会超出int的范围
4. 这道题其实正解应该是动态规划，最优解是有限状态机

### 安卓手势系统解锁
1. 这道题和上面那道题相似的地方在于统计个数的部分，这道题也是在递归的结果长度等于n个点的时候，return 1，除此之外的每轮递归把计数结果ans return。但这道题要注意一点就是**当长度大于m个点的时候，ans要置为1，小于m的时候是ans := 0**
