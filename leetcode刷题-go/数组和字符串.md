# 数组和字符串
## 合并区间
+ 解题关键
  1. 先排序，再合并
  
  

## 旋转数组
+ 解题关键
  1. 翻转法：先全部翻转，再前k个翻转，后面的翻转就可以了
  2. 环装替换：注意是两层循环，外层循环数是最大公约数。内层循环结束条件是从开始位置绕回起始位置

求两个数(a,b)的最大公约数：
for a != 0 {
    a, b = b % a, a
}

## 旋转矩阵
+ 解题关键
  1. 原地中心对称法：左上角那个小正方形中的每个点都有自己对应的四个中心对称的点，将这四个点旋转即可（从四个中心对称点与中轴线的距离比较来思考）。注意当行数或列数为奇数时一定要注意，中轴线上是有值的，这个时候！！！左上角那个小正方形的中轴线部分只能有一边被旋转，不然就重复旋转了。
  2. 主对角线翻转 + 水平轴翻转，注意是两次翻转

## 零矩阵
+ 解题关键
  1. 用一个标记flag记录第一行有没有0，用（0，0）记录第一列有没有0，其他位置均用(0,j)和(i,0)来标记是否要把这一列或者这一行置0，注意这样弄了以后，一定要从二维数组的最后一个数字开始遍历，因为你要是从头开始遍历很可能会导致两个结果
    + 由于第一列有0，从头遍历的时候，导致第一行的所有数据都变成了0，这样会导致整个矩阵都变0
    + 由于第一列有0，遍历每一行的时候，导致每一行第一个数变成0，在遍历这一行后面的数字的时候会导致后面的数字都被置0，从而导致整个矩阵被置0



## KMP 匹配
1. labuladong永远的神，关于KMP原理解释是神仙级别的解释，但是他的那个二维dp数组非常不可取，可以理解他讲的，然后再去看leetcode上面那个KMP的介绍，那个next数组的原理就显得非常显而易见了：<https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484731&idx=2&sn=d9d6b24c7f94d5e43e08666e82251984&scene=21#wechat_redirect>
我这里简单解释一下leetcode 上面那个next数组的意义<https://leetcode-cn.com/leetbook/read/array-and-string/cpoo6/>，他这个最长公共前后缀，即某个字符A前面所有字符的头尾相同的字符数，有了这个字符数之后，我们就知道当匹配到A的时候，如果失败了，pattern应该从第几个字符开始匹配，相当于记录了一个回退状态，这个状态在匹配失败时触发，把pattern回退到哪一个状态继续匹配。**一定要注意！！！！KMP匹配中原字符串的指针永远不回退，永远继续**
2. next数组里面的对应位置的数字num是指当pattern匹配的这一位，如果失败了，pattern的指针就转向num位置接着匹配，**注意是接着匹配，意思是转换完成后直接就可以判断是否相等，主串不需要进一匹配**
3. next[0]为-1，这是为了计算方便，因为next中别的位置的数字都是转换完就可以匹配了，只有0位置，如果next[0] = 0 你转换完，理论上还是当前位置，主串必须得进1匹配（见2），为了统一，我们把next[0]设为-1，这样在pattern和主串的指针都进1的那个判断中加一个当p(模式串指针)<0时，也走这个判断即可。next[0] = -1还方便了next数组的构建，因为构造next数组本质也就是匹配过程
4. 关于next数组的计算有些很巧妙的东西，其实next数组的计算其实就是模式串与模式串进行匹配，可是这个匹配并不是对应位置匹配，**而是错开的**，什么意思？假设模式串是p，在构造next数组中，p代表主串，pp代表模式串，所谓错开匹配就是让p和pp的指针一开始错开，p的指针p1从0开始，pp的指针p2从-1开始，和正常匹配一样，当发现p2<0的时候，我们同时增加p1和p2指针，然后赋值，这个时候next[1] = 0，非常完美了。接着是从pp[0]去匹配p[1]开始的，这是多米诺骨牌的第一步，这样计算出的是next[2]。当发现不匹配的时候p2就可以根据next转换了，因为next肯定快于p2（next是跟着p1走的）所以p2就可以非常完美的转换到下一个匹配的位置，直接继续匹配，和正常匹配一样。如果发现pp指针p2一直转到0还不可以，就直接转成-1，和正常匹配一样。
5. 匹配和构造next数组的结构是一样的，只不过正常匹配不用错开匹配，因此都从0开始就行了。
6. 如果针对主串的指针写成那种三段式的，那么循环体里面还应该一个循环用来迭代next用来找needle的”失败指针“，这种三段式的我用在那个AC自动机里面



### 等差数列划分
1. 这道题是滑动窗口，但是不用模板，思考的时候从暴力搜索开始，寻找所有的子数组然后找到形成等差序列的子数组，暴力寻找等差数组是从子数组头迭代到尾，但实际发现只要发现子数组的后三位不形成等差列就可以break了，进而进化到双指针。
2. 双指针过程和模板基本一致，只不过写法不一样。除此之外要注意当等差列长度只要大于3的时候就要每轮加1，

### [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

1. 这道题的方法就是

## Leetcode涉及两个数的和或差的问题
1. 两数之和/股票买卖问题
    注：股票买卖只讨论公共解法
    这两道题里面有一个特别相似的地方就是涉及到集合里面的两个数的差或和的问题，两数之和里面，要两个数A和B和为target，我们可以用一个循环给他搞定，就是考虑target-A，遍历A，一边把当前数字加入到hash表里面，一边判断hashMap[target-A]是否有值。股票的题目（一次买卖那种）里面，要求两数之差最大，就是一次遍历，边找最小的数字，边用当前数字减去最小的数字，即ans[i]-min


## 优势洗牌
田忌赛马类的题目
1. nums2本身并不能变，因为要根据nums2的顺序去排序nums1，因此应该新增一个结构去存储num2的每一个数字和对应的index，**除此之外结果切片也要新建。**
2. 题目的策略就是把nums1和nums2都降序排序，然后对应位置考虑。但是要注意当排序后的nums1比不过排序后nums2对应位置的数字时，nums1用最小的值填入结果切片，但是**nums1的指针不能变，nums2的指针要加1**，因此**必须用left，right控制nums1，用循环控制nums2**，**两种指针并存**。



## 区间问题
1. 区间问题，一般就是先排序，然后画图看看有多少种情况，具体分析见：<https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487316&idx=1&sn=95cfbbd24f1cb5d8c07c71c2ba15246a&chksm=9bd7f15caca0784ab7bce7f36a6eb9118de2a573515a99948168ed93b25069a3b7bf85cf50a5&scene=21#wechat_redirect>
2. 区间问题在迭代的时候一般都需要维护一个left和一个right（有时候只要一个，但每一道题都维护两个更有共性一点），left和right更新的时刻不一样，要分析一下
3. 其实区间问题还有一个比较关键的点要注意就是，你的注意力一定要在题目要求的那个点上面，着重讨论题目要求的那个点出现的情况。

### 合并区间
维护一个left，right作为区间左右点，当需要更新left的时候也就是加入结果的时候

### 删除被覆盖区间
这道题最大的问题是一定要注意要多字段排序，防止出现`[1,6],[1,2]`的情况，第一个字段升序，第二个字段降序。但这样就有一个问题，就是必须要维护一个right（这道题只需要维护一个right就行了），不能迭代过程中只和前一个作比较

### 区间列表的交集
这道题两个列表，用i,j作为两个列表中的指针，用于游走比较，可以用a1，a2, b1, b2代表两个列表中两个区间的头尾，方便讨论。关于i，j的前进只与当前比较的两个列表的尾部比较有关。



## 括号匹配类问题
凡是涉及到括号匹配的问题，如果有好几种括号，建议使用栈，见：有效的括号。如果只有一种括号，可以以左括号为基准用一个need表示需要的右括号
### 使括号有效的最少添加
一个res，一个need，分别代表过程中需要加入的左括号和右括号，当need=-1的时候res才加1，注意res和need只关心个数，不关心具体加在哪个位置

### 平衡括号字符串的最少插入次数
1. 一个res，一个need，分别代表过程中需要加入的括号（可能左可能右）和右括号
2. 遇到某一个左括号后面需要加的右括号个数不为偶数时，说明前面一定有一个左括号对应的括号少了1，（也有可能是")("的情况，但是这种操不操作结果没变，因此不影响）一定要停下来先把它加成偶数，因为这个左括号可能会把前面某个左括号本应凑成的两个右括号隔开，导致题目第一个条件不满足。
3. 第二点中，补成偶数的方式是：res+1，need-1，分别对应在前面某个位置补一个右括号，和因为补了一个右括号，对右括号的需求减1
4. need=-1时候，res只加1，不需要加2，也就是说res这时候只加一个左括号，然后need+1，因为如果直接让res加1，可能后面还有右括号导致加多了。



## 矩阵遍历
### 螺旋矩阵
1. 这道题第一个点是，外层循环index < m \*n，计数到m*n的时候跳出循环，外层循环内有四个小循环，每一个小循环结束以后，**要把边界收缩一下，边界位置必须是可索引的**
2. 这道题第二个点是千万要注意，其实这是一个编程的习惯了，只要出现索引，一定要想想循环不变量，就是这个索引不能越界，这个越界可能不是指向那种“数组的边界”，也有可能是循环不变量的边界，这道题里面每一轮大循环里面有四个小循环，每个小循环都要固定一个坐标，一定要注意这个固定的坐标不能“越界”。即左边界<=右边界，上边界>=下边界，这两个就是循环不变量
3. 因为假如上边界<下边界了，说明下边界那一行已经遍历过了，但是这个时候index>=m*n了，但是没有进入到外循环，**如果不加上边界>=下边界的话遍历不会停止**。

### 螺旋矩阵2
这道题和上一道题一样

### 翻转图像
这道题需要思考，如何一边遍历解决问题，因为既要翻转又要反转，所以可以把这两个操作合起来，对于每一行而言，如果前后的数字一致，就各自变化一下，**如果前后数字不一致，就什么都不做**



## 字符串问题

### 反转字符串中的元音字母

1. 这道题千万不要用map去做一个set，因为那样的话你map要写12行！因为这道题不是像上一道题那样返回小写结果，而是返回原结果！**所以不能提前转小写**
2. 这道题最好使用strings.Contains()这个函数去判断一个字母是不是元音字母，这个方法代码量最小最优雅。不要去用key为byte类型的map去判断

### 字符串匹配问题

以下几种问题都是两个字符串匹配的问题，他们的解题格式都是类似的，使用双指针，并采用非三段式的for循环，而且循环不变量的应用很重要

很多题目涉及到贪心算法

### 判断子序列

这道题是最简单的一道题目，双指针保证循环不变量（这就会有一快一慢了）

### 形成字符串的最短路径

这道题是判断子序列的进阶，区别在于，source串（即模式串）需要多次从头匹配。这一区别就导致了，外层循环不能监视模式串上的指针是否越界，因为它一定会越界，要在循环内部判断。还有两个注意点：

1. 最小数量从 1 开始，这个已经见到很多次了
2. 模式串指针置0的时候，目标串指针千万不能动！
3. 对于出现意外字符的情况，前面用个hashSet是最合理的解决方案

### [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

1. 这道题其实并不简单，首先暴力算法，就是迭代长度，然后内层迭代每个长度从0开始比较，比较到长度
2. 这道题牛逼的是字符串拼接的方法，直接给定字符串重复一下，然后去掉头尾各一个字母，然后查找是否包含字符串，这样做的原理是，如果没有重复段，字符串重复一下会有两个原字符串，去掉一头一尾就没有原字符串了，但是如果有重复段，第一个字符串的后段和第二个字符串的头段合起来会构成一个完整的源字符串

### [字符串相加](https://leetcode-cn.com/problems/add-strings/)

1. 这道题在最后返回前要加上可能的进位！！！

### 大数相减
<https://www.nowcoder.com/practice/ae4d84312e384a1fa100b613f93f3fe0?tpId=196&tqId=40449&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1%26search%3D%25E5%25A4%25A7%25E6%2595%25B0&difficulty=undefined&judgeStatus=undefined&tags=&title=%E5%A4%A7%E6%95%B0>
1. 大数相减有一个问题就是补0和去0的问题，两个指针分别游走在两个大数串上面，注意循环条件是：`for index1 >= 0 || index2 >= 0 `，千万注意不是&&，这个和大数相加是一样的，如果有一个指针已经小于0了，这个时候这个位置上就应该是个0。
2. 最后结果要把先导0去掉，这个是和相加不一样的，因为借位可能会把最高位借成0
3. 一定要用大的数减小的数，因此前面需要做一次判断和替换，**如果被减数小于减数，最后结果要加上负号**

### 大数相乘
<https://www.nowcoder.com/practice/c4c488d4d40d4c4e9824c3650f7d5571?tpId=196&tqId=37177&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=%2Fexam%2Foj%3Ftab%3D%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587%26topicId%3D196%26page%3D1%26search%3D%25E5%25A4%25A7%25E6%2595%25B0&difficulty=undefined&judgeStatus=undefined&tags=&title=%E5%A4%A7%E6%95%B0>
1. 这道题乘法部分和大数加法差不多，但是两个数相乘需要有一个**移位相加的过程**，这个过程容易忘，尤其是那个移位，每做一次加法，加数都要移位一个，因此要设定一个offset用来把加数移位

## 字典序问题
数组和字符串问题经常会看到按照字典序排序的问题

### [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

1. 这道题其实找两个数就行，**从后往前，找到第一个`nums[i] > nums[i-1]`的`i-1`**和**从后往前第一个大于`i-1`位置上的数的数**。这两个要用两个循环搞定。这也是一种思路，当你觉得一个循环难的时候，可以用两个循环
2. 这道题千万不能从前往后找第一个倒序的！！！！！，因为你找到需要交换的位置**这个位置的数后面的数都是倒序的**，才说明交换这个数带来的增量最小，因为要保证“后面的数”，所以必须从后往前
3. 找到上面那两个数以后，要交换一下，交换后还要把i-1后面的数字排个序，从小到大。**这个排序如果你仔细想想，其实就是翻转一下。但是注意如果最初的状态已经是倒序了（即i-1那个数没找到），这个时候直接翻转就行了**

### [计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/)
1. 这道题虽然是道简单题，但思路并不好想。具体思路是按顺序分组统计0,1的个数，比如`00111001`统计结果是`[2,3,2,1]`。然后具有相同数量的0,1子字符串数量是相邻两个计数的最小值。
2. 这道题由于每次只需要前后两个分组的个数就可以了，**因此可以边统计边计算**，具体就是一个lastCount和一个curCount，最好在字符串最后加一个不相关字符，比如`'-'`，这样计算过程可以全部放在循环里面。


## 投票问题

这里主要涉及的是摩尔投票法，本质就是抵消。这种方法可以在O(n)时复和O(1)空复的情况下找到，**出现次数超过 n / k 的（最多） k −1 个数**，证明：<https://leetcode-cn.com/problems/majority-element-ii/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-ws0rj/>

这道题有一个技巧就是，从0开始遍历数组，而且初始阶段，count一定要全部是0

### [多数元素](https://leetcode-cn.com/problems/majority-element/)

1. 这道题的核心就是在遍历数组的过程中选中一个数，为他计数，遍历过程中发现当前数与这个数不相等就计数-1，相等就计数+1，计数如果减到0，就在**下一个位置上（一定要记住是下一个位置上，因为当前位置的数只是用来抵消的）**，把这个数换掉。直到最后剩下来的那个数就是多数元素
2. 这道题可以随便弄一个起始，可以是不可达的一个数，也可以是数组中第一个数（为了和下一题保持一致），和它的计数（0个），然后开始遍历，虽然这个数可能一开始就会被换掉

### [求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)

1. 这道题和上面一样，只不过因为超过 n / k的数最多有k-1个，所以一开始要弄一个k-1个数的数组（如果数量不多可以直接弄k-1个数），然后相应的计数，这里还是和上面一样的计数和淘汰策略，但是最终剩下来的k-1个数并不一定都超过 n / 3，有可能只是出现在偏后面（前面全部自相残杀完了），**所以还需要再遍历一下数组（这个和前面不一样）**
2. 这道题的初始k-1个数可以随便选，只不过计数都是0，其他都跟上面一样，但是一定要注意因为数多了，**所以一轮循环中只有一个数的count会加1，只有一个数会被替换，但是可以多个数同时减1**，回过头遍历的时候也是注意一次只能有一个数计数（防止出现k-1个数里面有重复的


## 特判问题
### 验证IP地址
1. 这道题有几个题目隐含的特判：
  + Ipv4按.分割完只有4个，Ipv6按:分割完只有8个
  + Ipv4中前导0和'0'的区别
  + golang `strings.Split`如果有两个连着的分割符号，会分割出一个空的出来，因此`len(str) == 0`也是有可能的，因此`len(str) < 1`这个过滤条件不能少

