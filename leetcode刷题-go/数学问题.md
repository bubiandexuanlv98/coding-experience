# 数学问题

## 数论类

+ 求解质因数

  这里有一个巧妙的地方，就是外层的那个循环其实并不会“停留在”非质数，这是因为像6，49这样的数字，会在2，7的时候被除尽，在外层循环迭代到6，49的时候，剩余的n里面不包含这两个因子，而使得最内层的`if n % f != 0 { break }`直接结束内层循环，实现“不停留”

  ```go
  func primeFactor(n int) {
    for i=2; i<=n; i++ {  
      for n != f {
        if n % f != 0 { break }
        n /= f 
      }
  	}
  }
  ```

+ 求解最大公约数

  下面这个就是辗转相除法，计算公式就是：`gcd(a,b) = gcd(b,a mod b)`，定理是：两个整数的**最大公约数**等于其中较小的那个数和两数相除余数的最大公约数。

  ```go
  func gcd(a, b int) int { // 这里其实ab不用区分大小，因为后面的循环第一步会帮你分出来的
      for b != 0 {
          temp := a % b 
          a = b
          b = temp
      }
  }
  ```

+ 求解最小公倍数

  最小公倍数在程序上使用最大公约数来实现

  ```go
  func lcm(a, b int) int {
    return a * b / gcd(a, b)
  }
  ```

  

### 丑数

这道题就是确定了有三个候选质因子：2,3,5，然后看这个n能不能接连被这三个候选质因子轮番除，最后除尽，除不尽（最后结果`n != 1`）就说明不是丑数

### 丑数2

<https://leetcode-cn.com/problems/chou-shu-lcof/solution/chou-shu-ii-qing-xi-de-tui-dao-si-lu-by-mrsate/>这个题解解释的最清楚

1. 丑数的概念确定了，丑数 * 2 or 3 or 5一定也是丑数，而所有的丑数都是这样生成的，通过乘上2 / 3 / 5，变成新的丑数。如果有一个已知的丑数序列：a, b, c, d....

   那么这道题的丑数序列应该是合并这三个有序数组：

   ```go
   nums2 = {a*2, b*2, c*2, d*2...}
   nums3 = {a*3, b*3, c*3, d*3...}
   nums5 = {a*5, b*5, c*5, d*5...}
   ```

   这就需要三个指针p2，p3，p5。并且需要一个多米诺骨牌的最开始倒下的牌，这个起始就是1，也就是说1就是上面的a，它一个元素组成了最初的“已知丑数序列”

   接下来就是需要找到三个里面的序列里面的最小值，加入最终序列。

2. 这道题还有一个坑在等着你，就是如果出现了两个指针甚至三个指针指向的数是相同的时候，**相同的都要推进指针**，这里有个技巧就是写三个if语句，保证相同就推进指针

### 丑数3

这道题其实很难

1. 首先对于一个数X，我们是能确定`[0, X]`中有几个丑数的，直接用X/a、X/b、X/c就能计算出[0,X]范围内有多少数能被a或者b或者c整除，然后把它们加起来就是答案，。但是首先这里第一个问题是这三个X/a、X/b、X/c会有重复，而去重后的结果是：

   ```go
   X/a + X/b + X/c - X/lcm(a,b) - X/lcm(a,c) - X/lcm(b,c) + X/lcm(a,b,c)
   ```

   lcm代表最小公倍数，假设这里求出的丑数个数是n

2. 那么我们要先找到这个n，这里就可以使用二分法了，搜索右边界是n * 三数最小，左边界是三数最小（其实是可以优化的，但是懒得优化了），但是注意这里二分找出来的数不一定是丑数，加入我们找到包含n个丑数的数了，我们还要找到它的左边界

3. 2中的左边界是是：`x - min(x % a, x % b, x % c)` 。







