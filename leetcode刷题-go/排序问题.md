# 排序

稳定排序：冒泡，插入

不稳定排序：堆排，快排，选择排

## 冒泡排序

1. 传统冒泡排序的外层循环是指有多少个数字排序好了，这些排好的数字都在数组的末尾，所以内存循环要不需要超过这些数（因为这些数已经排好了），且内存循环要记住从0开始
2. 改进冒泡排序，外层循环去掉用swap开关代替，内存循环还是从0开始，同时存最后一个未被排序的位置的下标，后面每次内层迭代都不能超过这个下标

## 快速排序
go语言实现快排有几点要注意
快排其实整明白了，真的好多东西
（注：用partition表示每轮递归中分开数组的的那段代码）
+ go语言实现快排一定要让左右边界均可索引，partition的时候，left和right直接分别从左边界和右边界开始。
+ 选取什么点作为分割点（即左侧，右侧，还是随机），与partition中的for循环是先从右边开始还是先从左边开始高度关联，以升序排列为例（降序也一样）
  1. 当选择左侧边界作为分割点的时候，for循环中一定是右指针先移动，为什么？**因为右指针先移动就保证了最后一定不会停在一个大于分割点的位置**，这就保证最后用分割点和停止位置交换的时候，不会把大于分割点的位置交换到左边界去
  2. 如果我们随机选取数组leftBound到rightBound中的一个点作为分割点，**一定要注意，要先把它交换到左边界**，再用模板，因为如果你不交换，无论你在partition中是左边先开始还是右边先开始，**最后都有可能会停在一个（小于分割点，在分割点左边）或者（大于分割点，在分割点右边）的位置，然后你一交换就错了。**
  3. 因此核心问题是我们要减少可能性，**即通过让分割点在左边界或者右边界让最后停止的位置一定出现在分割点右侧**，**同时通过左右指针的先后移动顺序保证，最后一定停在小于分割点或者大于分割点的位置**
+ 实现细节
  1. partition里面双指针移动时一定要注意两点，第二点尤其重要：1. 每次移动都要保证right>left 2. 一定要是**等于等于等于！！！！**，即nums[right] >= base


### 快速排序亲兄弟快速选择
eg. 数组中的第 k 大的数字
这道题里面注意partition外面那个循环，类似于二分查找，按照二分查找的等于模板写即可

### 堆排序
首先需要建堆
<https://www.cnblogs.com/sunshineliulu/p/12995910.html>



## 归并排序

归并排序有几点需要注意：

1. 归并排序其实使用的是二叉树的后序遍历，把问题缩小到最少再开始操作（最少是1，直接返回），注意操作区间是双闭区间。
2. 优化的方向是只使用一个result数组作为临时开辟的变量存所有的结果。注意这里会有一个问题，就是**每次merge以后要把result里面的start到end的结果写会原数组**，这是因为每次merge的时候，两个数组比较的过程是通过比较原数组完成的。注意不能全部写到result里面用result比较，因为那样就会边读边写，会发生覆盖，影响判断
3. 每次merge的时候不要吝啬变量，尤其注意那个result中的指针，如果搞不好就新建一个resultIndex，这样稳妥。其实这个resultIndex是可以被index1 + index2 - start2替代的，要注意那个index2 - start2

### [数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

1. 这道题是在归并排序的过程中计数，因为归并排序会把数字提出来两两比较，符合逆序对查找原则
2. 这道题计数的坑在于**当右边数组中的数字往result里面填一个的时候，这个时候计数要加上左边数组剩下的所有数**

### [排序链表](https://leetcode-cn.com/problems/sort-list/)

1. 这道题是可以用归并排序的，注意链表排序可以使用插入排序，和归并排序，这两个都符合链表的特性。快排不行，因为快排每轮中需要从后往前，单链表做不到。
2. 用归并排序排序链表的时候是不需要end的，**这里可以直接把mid的下一个置为nil，这样就不需要end了，默认end都是nil**。而且这样操作也可以统一前半段和后半段的end
3. mid是需要单独写一个函数来找的。