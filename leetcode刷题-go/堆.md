# 堆
## golang 使用内部库构造堆
参考网站： <https://studygolang.com/articles/11653?fr=sidebar>
Go编程经验里面也有

## 如何建堆（用于堆排）
+ 如果有一个已经存好数字的数组
大顶堆的构建过程就是从最后一个非叶子结点开始从下往上调整。调整的时候采用sink
<https://www.cnblogs.com/sunshineliulu/p/12995910.html>
有两种sink框架，一种是迭代，一种是递归
  + 迭代法
    1. 迭代的需要注意，那个下沉的对象每轮循环的最后要更新，left和right最好单写两个函数，循环结束的条件是left(i)超出索引范围
  + 递归法
    1. 要注意，进入递归的条件是在一个三角树中进行三角比较时，最大的那个数字的标不是当前三角树的顶
    2. 三角比较并时要加一个判断：left和right都不能超过数组长度

+ 如果是一个空的数组
一般采取在数组后面加入数字，然后swim
有两种swim框架，和sink一样。
  + 递归法
    1. 只要比较一下当前数字和它的parent的大小就行了，不用跟它的兄弟节点比较
    2. 比较的时候要加一个判断，parent的坐标要大于等于0（和sink保持对称）



## 数组中第k大的数字
这个题目用堆排除了建堆的问题以外还有一个很重要的点：
如果想要从一个已经堆排过的数组中获得第k大的数字，首先要**头尾数字交换，然后把尾指针往前移动一个，再把交换过的头下沉到合适的位置上**

## 数据流中的中位数
1. 这道题需要一个大顶堆和一个小顶堆，各存一半的数据，如果加入的数字的个数是奇数选择一个堆加入，要保证大顶堆的数据都小于小顶堆的数据，也就是说大顶堆存的是小的那一半large，大顶堆存的是大的那一半small
2. 每次往小顶堆large里面加的时候要判断这个数字是否小于大顶堆small的堆顶，如果小于，如果自己实现的sink和swim要记得把大顶堆small的堆顶个待加入的数字互换一下，然后下沉大顶堆，再往小顶堆large里面加（加入小顶堆使用swim的方法）。每次往大顶堆里面加的时候同理
3. 第二步如果使用官方的，就不用判断那个了，每次加堆的时候都先加一下另一个堆，然后pop出另一个堆的堆顶继续加。




