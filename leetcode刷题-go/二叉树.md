# 二叉树
## 小技巧
当使用递归的方法解题时，有时候不能用原函数直接递归，可能需要辅助函数，辅助函数一般都是增加参数列表。有两种情况需要增加参数列表：
1. 需要在递归的过程中对某个节点加入限制，对上限或者下限的限制，且这个限制可能会随着节点的变化而变化
2. 需要在递归的过程中某个节点的值由两个节点共同决定，一般是由两个父节点共同决定

## 路径总和
不是看什么时候加到那个和，而是看什么时候减到0，这样会更简单一点

### [路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

1. 这道题有一个很有启发性的问题，就是假如出现对于一个节点而言，对这个节点和对这个节点的子节点需要进行相同的操作



## 树与链表

### [二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

+ 这道题非常好的一个理解二叉树递归的一道题，即在思考是使用前序还是后序还是中序的时候只考虑函数的整体作用，不考虑细节，确定框架以后再考虑细节
+ 这道题的解题思路就是：1. 左右子树拉平 2. 左子树接到右子树上，**同时左子树置空** 3. 原来的右子树往后接

### 将二叉搜索树转化为排序的双向链表

1. 二叉搜索树的很多题目都需要使用中序遍历去处理一些事情，这道题也不例外，中序遍历处理就是在两个递归之间写主要逻辑
2. 这道题最核心的一点就是不要想着用两个参数或者返回参数，因为这样还需要弄一个first和last去记录最后一个节点和第一个节点，索性就用函数外的一个last和一个first（注意first不游动，只是为了标记头节点），因为其实对于当前节点而言，我需要它的上一个节点，然后就可以串起来了，所以其实只要一个last不断的移动就可以。
3. 中序遍历里面只要右边没有节点了，那么last就定死了，不会随着递归的返回而变化了，这点很重要，因为达到最右边以后接下来就没有一行代码会执行了，因为你每一层返回都是最后一句（即“进入右循环”）

## 还原（反序列化）二叉树
+ 一般语境下，单单前序遍历结果是不能还原二叉树结构的，**因为缺少空指针的信息**，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是如果有了空指针，就可以单凭一个遍历还原，因为空指针会指示一个节点是否是叶子节点。
+ 但是要注意中序遍历即使有空指针的指示，也无法反序列化，因为要想实现反序列方法，首先要构造 root 节点。前序遍历得到的列表中，第一个元素是 root 节点的值；后序遍历得到的列表中，最后一个元素是 root 节点的值。但是中序遍历的列表，root的值被夹在两颗子树的中间，我们不知道确切的索引位置，所以无法找到root节点。
+ 所有从两个序列还原二叉树的题目，**核心都是找出左子树有多大，或者右子树有多大，根据这个大小，去把某一个数组或者两个数组都分成两半**。遵循以下三步：
  1. 我们会顺序提取一个数组的值出来作为“分隔值”，最好统一使用递归，每次都取第一个值，不要用一个全局指针！！！
  2. 然后在另一个数组中找到这个分隔值对应的index，**从而把另一个数组分成“左子树段”和“右子树段”（前序+后序需要在一轮中把两个数组都分成两半）**
  3. 最后分治求出左子树和右子树。

###  [从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

1. 所有这些通过两个序列还原二叉树的题目，都是可以直接使用原函数，不使用新函数，但是如果为了加速计算，可以弄个hashMap，这个就需要新函数了，但新函数还是使用老函数的参数列表和返回值

### 寻找重复的子树

+ 这道题就是把每一个子树都序列化一下，然后用一个hashMap存一下，问题主要在序列化上
+ 序列化时一定要注意，left，right和当前值连接时要加逗号，空的节点要返回"#"



### [二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

1. 这道题层序遍历没什么好讲的，太简单了
2. 用DFS的方式有点意思，因为实际上提供一个思路，就是DFS如果你用隐式栈，需要压栈的元素就是就是函数的参数，如果你用显示栈，如果有多个元素需要每轮保存，那么就需要多个栈去做压栈出栈，比如这道题，需要depth和root两个栈
3. 这道题DFS解题还有一个问题，就是需要一个hash表，去记录当前深度的最右侧有没有被记录，如果记录过了说明当前深度最右侧已经有值了。要注意这里是一次性赋值，要保证hash表中每个深度第一次赋值一定是最右侧的。所以右先左后。

## 迭代解决二叉树

### 模板：

```
// 模拟函数调用栈
private Stack<TreeNode> stk = new Stack<>();

// 左侧树枝一撸到底
private void pushLeftBranch(TreeNode p) {
    while (p != null) {
        /*******************/
        /** 前序遍历代码位置 **/
        /*******************/
        stk.push(p);
        p = p.left;
    }
}

public List<Integer> traverse(TreeNode root) {
    // 指向上一次遍历完的子树根节点
    TreeNode visited = new TreeNode(-1);
    // 开始遍历整棵树
    pushLeftBranch(root);

    while (!stk.isEmpty()) {
        TreeNode p = stk.peek();

        // p 的左子树被遍历完了，且右子树没有被遍历过
        if ((p.left == null || p.left == visited) 
          && p.right != visited) {
            /*******************/
            /** 中序遍历代码位置 **/
            /*******************/
            // 去遍历 p 的右子树
            pushLeftBranch(p.right);
        }
        // p 的右子树被遍历完了
        if (p.right == null || p.right == visited) {
            /*******************/
            /** 后序遍历代码位置 **/
            /*******************/
            // 以 p 为根的子树被遍历完了，出栈
            // visited 指针指向 p
            visited = stk.pop();
        }
    }
}
```

模板几点说明：

1. 为什么(p.left == null || p.left == visited) && p.right != visited，这个条件前一个条件是为了判断左边已经遍历完了，可以看成是从左边上来的，后面一个条件是为了保证此时并没有遍历右边，保证不可能是从右边上来的。（因为有可能出现`p.left == nil, p.right != nil`的情况，这种节点无论从左边上来的还是从右边上来的，都满足前一个条件）
2. 为什么visited初始化为一个树里面没有的节点，而不能初始化为nil？还是因为(p.left == null || p.left == visited) && p.right != visited的第二个条件，如果visited初始化为nil，那么有可能不是从右边上来的，但p.right == visited （都是nil），比如对于所有的叶子节点都存在这个问题。
3. 为什么左右都有p.left == nil 和p.right == nil 这个条件，这是因为visited初始不能是nil，所以防止遗漏

## 字典树/前缀树

### 前缀树

三个点要注意：

1. 结点中并没有直接保存字符值的数据成员！！！！！，结点成员一个是布尔值用于判断此节点是不是尾结点，另一个是一个列表。
2. 用一个列表保存下一个可能节点（一共有26中可能性，因此列表长度为26）的地址，列表里面会有很多nil
3. 那个列表的索引是当前字符ch减去'a'

### [字典序的第K小数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

这是一道特殊的前缀树问题，我愿称之为leetcode中题目最简单，思路最巧妙的一道题

1. 这道题要画个前缀树就很明显了，树的第一层是1，2，3，4....，第二层是10，11，12....，1到2的距离实际上是1下面所有子节点的个数，这就构成了一个区间。找第k小的数字实际上就是确定这个k在哪个区间的问题，一步步逼近
2. 这道题有两个核心问题，一个是怎么确定当前节点下面有多少子节点，另一个是怎么缩小空间。第一个问题很巧妙，实际上是一个cur，一个next（等于cur+1）然后让他俩相减，然后乘10相减，不断循环，直到cur > n，**注意这里会有一个问题就是next也不能超过n。这就会有一个sum没超过n，但next超过n的情况，这种情况下应该用sum+1去减cur**，因此可以这样写循环内计算个数的公式：`ans = min(next, sum+1) - cur`
3. 在确定k所在区间的时候也有一个技巧，我们是找第k个数字，每轮确定的时候，都要在同一层上确定它在哪两个数之间，而同一层上，比如1，2之间我们要确定的是k是否在：`[1的位置，2的位置]`这个闭区间内，确定2的位置的时候，假设1下面子节点的个数count，`2的位置 = count + 1的位置 + 1`，这一套如何保证：要保证2中计算1下面子节点个数时，本节点也要计数
4. 根据字典树，再层层往下确定区间的时候，cur * 10，在同一层上确定的时候cur + 1

### [搜索推荐系统](https://leetcode.cn/problems/search-suggestions-system/)

1. 凡是遇到字符串前缀匹配的题目，都可以用字典树来解决。
2. 这道题的字典树有一个小技巧，就是**每加入单词遍历到一个节点时就把当前单词保留到节点中去**，最好用个优先级队列排一下，每个节点只按字典序保留前三个单词。这样最后搜的时候直接就把当前节点的单词加进去即可

### 修建二叉树

1. **所有修剪，剪枝二叉树的题目的递归函数都可以返回一个节点，也基本不需要重新定义函数增加参数列表之类的**
2. 这道题核心就在于要看出来如果节点值小于low，说明结果在右边，节点值要是大于low说明结果在左边，这两种情况都是当前节点不考虑了。等于的时候可以不处理，因为最后肯定会正常返回的，处理一下可以减少一些递归

### 二叉树剪枝

1. 这道题剪枝的条件是，节点值为0，且左右子树全是0，这就是一个后序遍历的条件，因为本节点的值一下就判断了，而左右子树的判断需要走递归，因此一个节点的decision需要先遍历完左右子树才能决定。
2. 如果上面三个条件都满足，则减去这个节点，即返回nil

### [完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

1. 这个问题首先是常规解法，求二叉树节点个数：1 + countNodes(root.Left) + countNodes(root.Right) 典型的后序（也可以说是前序）遍历
2. 求完全二叉树节点个数可以类比求满二叉树节点个数，满二叉树节点个数是2^树高-1，其实对于完全二叉树的任何一个节点，都只有两种情况，要么左子树是满二叉，右子树不是满二叉。要么两个都是满二叉。针对这个性质可以每次判断一下节点的左边是不是和右边高度一样，一样的话说明是满二叉，直接用满二叉的公式。如果不一样，就是第一种情况，那么就用常规解法
3. 这道题最牛逼的地方在于2的时间复杂度是：logN * logN


# 搜索二叉树
## 特性
**二叉搜索树插入的节点一定是叶子节点！！！！** 这个是BST的特性之一
### 增删改查BST中的元素

模板：
```
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```
1. BST的增加元素有点类似于二分搜索，跟二叉树不一样，他不需要遍历整个树，而是对于每个节点只需遍历其中一个分支即可
2. BST的删除元素要注意针对要删除的节点的左右子节点都有值的情况，要先去寻找待删除节点左子树中的最大值或者右子树中的最小值，然后将这个最大或最小值与待删除节点的值交换，再删除这个最大或最小值的节点，这样代码量最少



### 删除二叉搜索树中的节点

1. 这道题先搜索，然后搜索到待删除的节点要分三种情况讨论，分别是这个节点左边没值，右边没值，以及左右都有值
2. 对于左右都有值的情况，应该选取下一个**值**然后和当前**值**替换，**然后继续递归删除**

### 将二叉搜索树转换为累加树

+ 注意这里一个小trick是用一个外部变量ans记录累加结果，再一个一个赋给节点值

### 验证二叉搜索树

+ 注意这道题用递归的话，递归函数参数要有一个upper一个lower

### 二叉搜索树的最近公共祖先

这个一定要考虑二叉搜索树的性质。如果一个节点是p或者q，那么它一定是最近公共祖先。如果p，q的value一个大于当前节点，另一个小于当前节点，那这个节点一定是最近公共祖先

### 不同的二叉搜索树

这道题就是从1到n分别作根节点。这样每个节点做根节点的时候，这棵树都被分成了两半，这两半再各自递归。注意最后答案是左树个数*右树个数。注意不要尝试只遍历一般，但可以用memo。最后一点就是n=1或n=0都是返回1的，因为是相乘的关系

### 不同的二叉搜索树（把所有的BST都要建立起来）

1. 递归的时候不能用原函数，因为参数不能只有一个n，参数要有lower和upper
2. 循环是这面很关键的一个点，三个嵌套循环，新建node必须要在最里面的循环做。第二层和第三层是遍历左子树和右子树，第一层是用来遍历根节点。每一个值都要做一次根节点

### 将二叉搜索树转化为排序的双向链表

1. 二叉搜索树的很多题目都需要使用中序遍历去处理一些事情，这道题也不例外，中序遍历处理就是在两个递归之间写主要逻辑
2. 这道题有一个需求很关键，就是要把首尾相连形成循环链表，这点特别重要。因为你需要用两个指针标志“首”和“尾”，具体操作就是first指针是一次性赋值，而last指针是随着递归一步一步转换到最后一个节点上的。
3. 这道题有一个trick：就是你只需要把左半边处理好，右半边留到下一轮，下一轮的左半边就是本轮的右半边。

### 恢复二叉搜索树

1. 首先你要能看出来，在递归遍历过程中修改什么是不现实的！！！因为把一个节点的值交换到当前位置，即使当前位置是满足的，当前位置的所有前序节点你仍然需要重新遍历一遍，而递归遍历是不回头的！！！！！
2. **这道题唯一的办法就是在中序遍历过程中把那两个错位的节点找到，然后最后交换**。注意找的过程中要有一个pre节点，保留着上一个节点（这个方法在“将二叉搜索树转化为排序的双向链表”也用到过）。发现pre>node的时候就是找到了
3. **要注意找到第一个数的时候，要用first记录pre，找到第二个数的时候要用second记录当前的node，最后把first和second交换**，但是注意有可能只能找到”一个数“，即两个数是连着的，这个时候一个trick就是在找到first的时候也把second赋值（first=pre, second=node）

### 二叉搜索树中的中序后继

1. 这道题实际上是一道二叉树搜索的问题，其实凡是遇到二叉树的问题，一定要想想两个特性一个是：中序遍历有序，另一个是二分搜索。凡是遇到搜索”搜索二叉树“中的某一个节点的时候，都要想到第二个特性
2. 二分搜索的时候，只要在p.Val < root.Val 的时候，就记录一下当前节点，因为他有可能是潜在的”后继节点“，这种边记录-边更新的操作在二叉搜索树中很常见。在p.Val >= root.Val的时候，把root转到root.Right上面
3. 这道题也可以用递归，只不过要有一个flag，去标志已经找到p了，然后记录flag为true以后的第一个root，即是答案

### [二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

1. 这道题是又是一道利用二叉搜索树的中序遍历性质的题目，要注意这道题告诉我们，递归其实就是一个指针在树上游走，这个指针是root，其实在做这道题之前先想想如何在有序数组上面找众数就明白这道题怎么写了
2. 还是一样用一个pre记录上一个节点，其余代码逻辑比较多，这里不说明。有一个点说明一下：循环不变量是那个结果数组ans，ans里面装的一定是maxCount的数字，**因此如果出现count>maxCount的数字，可以大胆把ans清空。**



## 二叉树数据结构设计

1. 如果让你实现一个二叉树有关的数据结构，并且有那种单个元素的操作，比如一个一个加，一个一个输出，这种一般都需要利用一个栈或者队列，或者是一个节点（目前我没遇到过）去存储待操作元素。
2. 这种题目的思考方式一般都是把一个个单次操作，变成一个一次性的操作，比如只有一次输出或者输入，且输出或输入多个。然后思考如何操作，再拆开成一个一个的操作

### [ 往完全二叉树添加节点](https://leetcode-cn.com/problems/NaqhDT/)

1. 这道题目如果让你一次性添加好多节点到完全二叉树里面去，实际上是层序遍历的过程，因此它保存一个队列即可，其实所有二叉树数据结构的题目都是保存着一堆下次需要操作的节点

## 二叉树反向寻找问题

二叉树的节点都是单链表，不存在回去的路，但是很多题目会要求反向寻找。除了在父节点提前处理外，还有一种技巧：记录每个子节点的父节点

### [二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

1. 这道题的技巧就是先找到target节点及其前面所有节点的父节点，可以用深度优先，也可以用广度优先。深度优先会存另一边的很多无用节点
2. 这时候再去搜索距离为k的节点就可以把父节点当成和left，right一样了，用递归搜索就可以。**但是会有一个问题就是要递归的时候要避免在两个点中无限循环，这个就要在递归函数参数中设置一个“访问过”或者“from”的节点。**不需要记录所有访问过的节点，只需要记录上一个访问的节点就行，并在此轮递归中做剪枝。

## 二叉树动态规划

### [打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

1. 这道题其实是下面二叉树染色的简化版，即只能连续涂1个点
2. 与二叉树染色一样，每一个节点定义两个状态，当前节点涂了很简单，只能用子节点没涂的情况计算。当前节点没涂要找下面两个节点涂或者不涂的最大值

### [二叉树染色](https://leetcode-cn.com/problems/er-cha-shu-ran-se-UGC/)

1. 这道题可以看成是一道有限状态机问题，这个状态并不是节点，而是“从这个节点往下涂几个颜色”，对于每个节点而言，状态有k+1个，即这个点不涂色，这个点及往下涂1个，涂2个.....涂k个，一般状态机的状态用切片或者map保存（map保存的AC自动机）
2. 当这个点不涂色的时候，即dp[0]应该是左边和右边涂色值最大的两个值的和。**当这个点涂色的时候，剩下i（i从1到k）个涂色的点要分到左右两边去（注意不是k个点，因为可能这个节点只能涂小于k个点）**
3. 根据上面的分析，这道题是一道典型的后序遍历的题目，为什么？**因为当前位置的状态，即涂i个色获得多少点数是不确定的，只有知道下面所有点的分数以后才能确定，所以必须先计算下面的点**

### [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

1. 这道题告诉我们函数的作用可能并不是求解，求解的过程是在递归中完成的，而递归函数的作用是为了辅助求解。
2. 递归函数有一个点，就是它必须是`当前节点的值 + 左右子树中的一个子树的路径最大值`，而不是当前节点做为父节点（其实就是一条路径的锚节点），能够串联起来的最大值（这个值实际上是最终答案需要的，这个值会在递归中不断更新ans）

